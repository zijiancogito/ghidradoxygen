\hypertarget{class_segment_op}{}\section{Segment\+Op Class Reference}
\label{class_segment_op}\index{SegmentOp@{SegmentOp}}


The {\itshape segmented} {\itshape address} operator.  




{\ttfamily \#include $<$userop.\+hh$>$}



Inheritance diagram for Segment\+Op\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=163pt]{class_segment_op__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Segment\+Op\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_segment_op_ad7459a581b241b35100f9fe260f0509f}{Segment\+Op}} (\mbox{\hyperlink{class_architecture}{Architecture}} $\ast$g, const string \&nm, int4 ind)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_constructor}{Constructor}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_addr_space}{Addr\+Space}} $\ast$ \mbox{\hyperlink{class_segment_op_aad3d01eb19ee086071c27d3c60be0f89}{get\+Space}} (void) const
\begin{DoxyCompactList}\small\item\em Get the address space being pointed to. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_segment_op_adeed973d1e49c68202121f4173150e31}{has\+Far\+Pointer\+Support}} (void) const
\begin{DoxyCompactList}\small\item\em Return {\bfseries{true}}, if {\bfseries{this}} op supports far pointers. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_segment_op_aacb606ca438d1a660222777c04d25d84}{is\+Forced}} (void) const
\begin{DoxyCompactList}\small\item\em Return {\bfseries{true}} if exceptions are thrown for bad unification. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_segment_op_adb895dfc740733c7106f3752bc4c6c1c}{get\+Base\+Size}} (void) const
\begin{DoxyCompactList}\small\item\em Get size in bytes of the base/segment value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_segment_op_a5b186649dadd3ed754fdfe26ba84c96b}{get\+Inner\+Size}} (void) const
\begin{DoxyCompactList}\small\item\em Get size in bytes of the near value. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \& \mbox{\hyperlink{class_segment_op_aee22fbc6dec027b9cc041c65c9681068}{get\+Resolve}} (void) const
\begin{DoxyCompactList}\small\item\em Get the default register for resolving indirect segments. \end{DoxyCompactList}\item 
virtual int4 \mbox{\hyperlink{class_segment_op_a0a5b69caea8e60eaebe045f49c9351e1}{get\+Num\+Variable\+Terms}} (void) const
\begin{DoxyCompactList}\small\item\em Get the number of input Varnodes expected. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48}{unify}} (\mbox{\hyperlink{class_funcdata}{Funcdata}} \&data, \mbox{\hyperlink{class_pcode_op}{Pcode\+Op}} $\ast$op, vector$<$ \mbox{\hyperlink{class_varnode}{Varnode}} $\ast$ $>$ \&bindlist) const
\begin{DoxyCompactList}\small\item\em Gather the formal input \mbox{\hyperlink{class_varnode}{Varnode}} objects given the root \mbox{\hyperlink{class_pcode_op}{Pcode\+Op}}. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{types_8h_a2db313c5d32a12b01d26ac9b3bca178f}{uintb}} \mbox{\hyperlink{class_segment_op_a1857d8c2eef84b0a8c1bb7c624210c6c}{execute}} (const vector$<$ \mbox{\hyperlink{types_8h_a2db313c5d32a12b01d26ac9b3bca178f}{uintb}} $>$ \&input) const
\begin{DoxyCompactList}\small\item\em Compute the output value of {\bfseries{this}} operation, given constant inputs. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_segment_op_a6f311b351e8d30119469650d5e33f84b}{restore\+Xml}} (const \mbox{\hyperlink{class_element}{Element}} $\ast$el)
\begin{DoxyCompactList}\small\item\em Restore the detailed description from an X\+ML stream. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
The {\itshape segmented} {\itshape address} operator. 

This op is a placeholder for address mappings involving {\bfseries{segments}}. The map goes between a {\bfseries{high-\/level}} view of a pointer, consisting of multiple pieces, and a {\bfseries{low-\/level}} view, where there is only a single absolute pointer. The mapping could be
\begin{DoxyItemize}
\item a virtual to physical mapping for instance or
\item a segment + near pointer to a full address
\end{DoxyItemize}

The output of the operator is always a full low-\/level pointer. The operator takes two inputs\+:
\begin{DoxyItemize}
\item the {\bfseries{base}} or {\bfseries{segment}} and
\item the high-\/level {\bfseries{near}} pointer
\end{DoxyItemize}

High-\/level analysis can ignore the base/segment and any normalization on the near pointer. Emitted expressions involving {\bfseries{this}} segment op prints only the {\bfseries{near}} portion. Data-\/type information propagates only through this high-\/level side.

The decompiler looks for the term-\/tree defined in \mbox{\hyperlink{class_segment_op}{Segment\+Op}} and replaces it with the S\+E\+G\+M\+E\+N\+T\+OP operator in any p-\/code it analyzes. The core routine that looks for the term-\/tree is \mbox{\hyperlink{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48}{unify()}}. 

Definition at line 199 of file userop.\+hh.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_segment_op_ad7459a581b241b35100f9fe260f0509f}\label{class_segment_op_ad7459a581b241b35100f9fe260f0509f}} 
\index{SegmentOp@{SegmentOp}!SegmentOp@{SegmentOp}}
\index{SegmentOp@{SegmentOp}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{SegmentOp()}{SegmentOp()}}
{\footnotesize\ttfamily Segment\+Op\+::\+Segment\+Op (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_architecture}{Architecture}} $\ast$}]{g,  }\item[{const string \&}]{nm,  }\item[{int4}]{ind }\end{DoxyParamCaption})}



\mbox{\hyperlink{class_constructor}{Constructor}}. 


\begin{DoxyParams}{Parameters}
{\em g} & is the owning \mbox{\hyperlink{class_architecture}{Architecture}} for this instance of the segment operation \\
\hline
{\em nm} & is the low-\/level name of the segment operation \\
\hline
{\em ind} & is the constant id identifying the specific C\+A\+L\+L\+O\+T\+H\+ER variant \\
\hline
\end{DoxyParams}


Definition at line 121 of file userop.\+cc.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_segment_op_a1857d8c2eef84b0a8c1bb7c624210c6c}\label{class_segment_op_a1857d8c2eef84b0a8c1bb7c624210c6c}} 
\index{SegmentOp@{SegmentOp}!execute@{execute}}
\index{execute@{execute}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{execute()}{execute()}}
{\footnotesize\ttfamily \mbox{\hyperlink{types_8h_a2db313c5d32a12b01d26ac9b3bca178f}{uintb}} Segment\+Op\+::execute (\begin{DoxyParamCaption}\item[{const vector$<$ \mbox{\hyperlink{types_8h_a2db313c5d32a12b01d26ac9b3bca178f}{uintb}} $>$ \&}]{input }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Compute the output value of {\bfseries{this}} operation, given constant inputs. 


\begin{DoxyParams}{Parameters}
{\em input} & is the ordered list of constant inputs \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the resulting value as a constant 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_term_pattern_op_a766fd191b337e60fb882b2e7bc9b42a6}{Term\+Pattern\+Op}}.



Definition at line 181 of file userop.\+cc.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_a1857d8c2eef84b0a8c1bb7c624210c6c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_adb895dfc740733c7106f3752bc4c6c1c}\label{class_segment_op_adb895dfc740733c7106f3752bc4c6c1c}} 
\index{SegmentOp@{SegmentOp}!getBaseSize@{getBaseSize}}
\index{getBaseSize@{getBaseSize}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{getBaseSize()}{getBaseSize()}}
{\footnotesize\ttfamily int4 Segment\+Op\+::get\+Base\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get size in bytes of the base/segment value. 



Definition at line 215 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_adb895dfc740733c7106f3752bc4c6c1c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_a5b186649dadd3ed754fdfe26ba84c96b}\label{class_segment_op_a5b186649dadd3ed754fdfe26ba84c96b}} 
\index{SegmentOp@{SegmentOp}!getInnerSize@{getInnerSize}}
\index{getInnerSize@{getInnerSize}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{getInnerSize()}{getInnerSize()}}
{\footnotesize\ttfamily int4 Segment\+Op\+::get\+Inner\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get size in bytes of the near value. 



Definition at line 216 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_a5b186649dadd3ed754fdfe26ba84c96b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_a0a5b69caea8e60eaebe045f49c9351e1}\label{class_segment_op_a0a5b69caea8e60eaebe045f49c9351e1}} 
\index{SegmentOp@{SegmentOp}!getNumVariableTerms@{getNumVariableTerms}}
\index{getNumVariableTerms@{getNumVariableTerms}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{getNumVariableTerms()}{getNumVariableTerms()}}
{\footnotesize\ttfamily virtual int4 Segment\+Op\+::get\+Num\+Variable\+Terms (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Get the number of input Varnodes expected. 



Implements \mbox{\hyperlink{class_term_pattern_op_a3978a156aa6681432b937361a2294f5d}{Term\+Pattern\+Op}}.



Definition at line 218 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_a0a5b69caea8e60eaebe045f49c9351e1_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_aee22fbc6dec027b9cc041c65c9681068}\label{class_segment_op_aee22fbc6dec027b9cc041c65c9681068}} 
\index{SegmentOp@{SegmentOp}!getResolve@{getResolve}}
\index{getResolve@{getResolve}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{getResolve()}{getResolve()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}}\& Segment\+Op\+::get\+Resolve (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the default register for resolving indirect segments. 



Definition at line 217 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_aee22fbc6dec027b9cc041c65c9681068_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_aad3d01eb19ee086071c27d3c60be0f89}\label{class_segment_op_aad3d01eb19ee086071c27d3c60be0f89}} 
\index{SegmentOp@{SegmentOp}!getSpace@{getSpace}}
\index{getSpace@{getSpace}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{getSpace()}{getSpace()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_addr_space}{Addr\+Space}}$\ast$ Segment\+Op\+::get\+Space (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the address space being pointed to. 



Definition at line 212 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_aad3d01eb19ee086071c27d3c60be0f89_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_adeed973d1e49c68202121f4173150e31}\label{class_segment_op_adeed973d1e49c68202121f4173150e31}} 
\index{SegmentOp@{SegmentOp}!hasFarPointerSupport@{hasFarPointerSupport}}
\index{hasFarPointerSupport@{hasFarPointerSupport}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{hasFarPointerSupport()}{hasFarPointerSupport()}}
{\footnotesize\ttfamily bool Segment\+Op\+::has\+Far\+Pointer\+Support (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return {\bfseries{true}}, if {\bfseries{this}} op supports far pointers. 



Definition at line 213 of file userop.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_adeed973d1e49c68202121f4173150e31_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_aacb606ca438d1a660222777c04d25d84}\label{class_segment_op_aacb606ca438d1a660222777c04d25d84}} 
\index{SegmentOp@{SegmentOp}!isForced@{isForced}}
\index{isForced@{isForced}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{isForced()}{isForced()}}
{\footnotesize\ttfamily bool Segment\+Op\+::is\+Forced (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return {\bfseries{true}} if exceptions are thrown for bad unification. 



Definition at line 214 of file userop.\+hh.

\mbox{\Hypertarget{class_segment_op_a6f311b351e8d30119469650d5e33f84b}\label{class_segment_op_a6f311b351e8d30119469650d5e33f84b}} 
\index{SegmentOp@{SegmentOp}!restoreXml@{restoreXml}}
\index{restoreXml@{restoreXml}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{restoreXml()}{restoreXml()}}
{\footnotesize\ttfamily void Segment\+Op\+::restore\+Xml (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_element}{Element}} $\ast$}]{el }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Restore the detailed description from an X\+ML stream. 

The details of how a user defined operation behaves can be dynamically configured from an X\+ML tag. 
\begin{DoxyParams}{Parameters}
{\em el} & is the root X\+ML element describing the op \\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{class_user_pcode_op_a2a7b7c637369bc4fba4604cd83a937af}{User\+Pcode\+Op}}.



Definition at line 195 of file userop.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_a6f311b351e8d30119469650d5e33f84b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_a6f311b351e8d30119469650d5e33f84b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48}\label{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48}} 
\index{SegmentOp@{SegmentOp}!unify@{unify}}
\index{unify@{unify}!SegmentOp@{SegmentOp}}
\subsubsection{\texorpdfstring{unify()}{unify()}}
{\footnotesize\ttfamily bool Segment\+Op\+::unify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_funcdata}{Funcdata}} \&}]{data,  }\item[{\mbox{\hyperlink{class_pcode_op}{Pcode\+Op}} $\ast$}]{op,  }\item[{vector$<$ \mbox{\hyperlink{class_varnode}{Varnode}} $\ast$ $>$ \&}]{bindlist }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Gather the formal input \mbox{\hyperlink{class_varnode}{Varnode}} objects given the root \mbox{\hyperlink{class_pcode_op}{Pcode\+Op}}. 


\begin{DoxyParams}{Parameters}
{\em data} & is the function being analyzed \\
\hline
{\em op} & is the root operation \\
\hline
{\em bindlist} & will hold the ordered list of input Varnodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the requisite inputs were found 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_term_pattern_op_afe2a8a69c8f803e3134eaaaf087cc0b0}{Term\+Pattern\+Op}}.



Definition at line 152 of file userop.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=336pt]{class_segment_op_acb25104d3aad5e44a3c9d5b471e39c48_icgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
F\+:/re/ghidra\+\_\+sourcecode/ghidra/\+Ghidra/\+Features/\+Decompiler/src/decompile/cpp/\mbox{\hyperlink{userop_8hh}{userop.\+hh}}\item 
F\+:/re/ghidra\+\_\+sourcecode/ghidra/\+Ghidra/\+Features/\+Decompiler/src/decompile/cpp/\mbox{\hyperlink{userop_8cc}{userop.\+cc}}\end{DoxyCompactItemize}
