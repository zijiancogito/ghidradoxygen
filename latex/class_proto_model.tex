\hypertarget{class_proto_model}{}\section{Proto\+Model Class Reference}
\label{class_proto_model}\index{ProtoModel@{ProtoModel}}


A {\bfseries{prototype}} {\bfseries{model\+:}} a model for passing parameters between functions.  




{\ttfamily \#include $<$fspec.\+hh$>$}



Inheritance diagram for Proto\+Model\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=178pt]{class_proto_model__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \mbox{\hyperlink{class_proto_model_ab532221dd4a9946b2dea90be44c79879ab0874d825448e7c731717fad59bbec92}{extrapop\+\_\+unknown}} = 0x8000
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_proto_model_a4ef7db884a8c5bcdea92ed7b2d6a9ac0}{Proto\+Model}} (\mbox{\hyperlink{class_architecture}{Architecture}} $\ast$g)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_constructor}{Constructor}} for use with \mbox{\hyperlink{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8}{restore\+Xml()}} \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_proto_model_a6385c58ce2f155d13f506c64a7a03b11}{Proto\+Model}} (const string \&nm, const \mbox{\hyperlink{class_proto_model}{Proto\+Model}} \&op2)
\begin{DoxyCompactList}\small\item\em Copy constructor changing the name. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{class_proto_model_ae253f61258ac2ad8f165200d1737e7a3}{$\sim$\+Proto\+Model}} (void)
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
const string \& \mbox{\hyperlink{class_proto_model_a19f8d9a9dbc7fb8d52aa180410cddc8b}{get\+Name}} (void) const
\begin{DoxyCompactList}\small\item\em Get the name of the prototype model. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_architecture}{Architecture}} $\ast$ \mbox{\hyperlink{class_proto_model_a256b9f054603fd6d166fdf86689467bf}{get\+Arch}} (void) const
\begin{DoxyCompactList}\small\item\em Get the owning \mbox{\hyperlink{class_architecture}{Architecture}}. \end{DoxyCompactList}\item 
uint4 \mbox{\hyperlink{class_proto_model_a5bd9f07bc75fc5f2497f1d4de685a8cf}{has\+Effect}} (const \mbox{\hyperlink{class_address}{Address}} \&addr, int4 size) const
\begin{DoxyCompactList}\small\item\em Determine side-\/effect of {\bfseries{this}} on the given memory range. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_a640ae87320b6d6781639643057e61e1d}{get\+Extra\+Pop}} (void) const
\begin{DoxyCompactList}\small\item\em Get the stack-\/pointer {\itshape extrapop} for {\bfseries{this}} model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_proto_model_a42eb0adf6bb66f15bbbde19c02c931ca}{set\+Extra\+Pop}} (int4 ep)
\begin{DoxyCompactList}\small\item\em Set the stack-\/pointer {\itshape extrapop}. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_af505f8d493ab0dcefca9e94941c13658}{get\+Inject\+Upon\+Entry}} (void) const
\begin{DoxyCompactList}\small\item\em Get the inject {\itshape uponentry} id. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_a2e8994c68acebcf5c0278d86be39a530}{get\+Inject\+Upon\+Return}} (void) const
\begin{DoxyCompactList}\small\item\em Get the inject {\itshape uponreturn} id. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_proto_model_a7f6da17343cb12b0e798fe7211441c58}{derive\+Input\+Map}} (\mbox{\hyperlink{class_param_active}{Param\+Active}} $\ast$active) const
\begin{DoxyCompactList}\small\item\em Given a list of input {\itshape trials}, derive the most likely input prototype. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_proto_model_a463595607985ec774f3df35dfbd7ca94}{derive\+Output\+Map}} (\mbox{\hyperlink{class_param_active}{Param\+Active}} $\ast$active) const
\begin{DoxyCompactList}\small\item\em Given a list of output {\itshape trials}, derive the most likely output prototype. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_proto_model_a5c32e533f079fc91875ccd486f70f36e}{assign\+Parameter\+Storage}} (const vector$<$ \mbox{\hyperlink{class_datatype}{Datatype}} $\ast$ $>$ \&typelist, vector$<$ \mbox{\hyperlink{struct_parameter_pieces}{Parameter\+Pieces}} $>$ \&res, bool ignore\+Output\+Error)
\begin{DoxyCompactList}\small\item\em Calculate input and output storage locations given a function prototype. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a06031cb84a876e36a3648362c4af8662}{check\+Input\+Join}} (const \mbox{\hyperlink{class_address}{Address}} \&hiaddr, int4 hisize, const \mbox{\hyperlink{class_address}{Address}} \&loaddr, int4 losize) const
\begin{DoxyCompactList}\small\item\em Check if the given two input storage locations can represent a single logical parameter. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a0e0ae91c9fa12f548418c469f63c9d1d}{check\+Output\+Join}} (const \mbox{\hyperlink{class_address}{Address}} \&hiaddr, int4 hisize, const \mbox{\hyperlink{class_address}{Address}} \&loaddr, int4 losize) const
\begin{DoxyCompactList}\small\item\em Check if the given two output storage locations can represent a single logical return value. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a6ddc6e7d218491b657d1f5e5bb997592}{check\+Input\+Split}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size, int4 splitpoint) const
\begin{DoxyCompactList}\small\item\em Check if it makes sense to split a single storage location into two input parameters. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_range_list}{Range\+List}} \& \mbox{\hyperlink{class_proto_model_a4736d007016235f93ae81100f8312e26}{get\+Local\+Range}} (void) const
\begin{DoxyCompactList}\small\item\em Get the range of (possible) local stack variables. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_range_list}{Range\+List}} \& \mbox{\hyperlink{class_proto_model_a2a83c006b588fad0b0842c6f9862e66b}{get\+Param\+Range}} (void) const
\begin{DoxyCompactList}\small\item\em Get the range of (possible) stack parameters. \end{DoxyCompactList}\item 
vector$<$ \mbox{\hyperlink{class_effect_record}{Effect\+Record}} $>$\+::const\+\_\+iterator \mbox{\hyperlink{class_proto_model_a5c9fa95940e32b03d475257ca177cfaa}{effect\+Begin}} (void) const
\begin{DoxyCompactList}\small\item\em Get an iterator to the first \mbox{\hyperlink{class_effect_record}{Effect\+Record}}. \end{DoxyCompactList}\item 
vector$<$ \mbox{\hyperlink{class_effect_record}{Effect\+Record}} $>$\+::const\+\_\+iterator \mbox{\hyperlink{class_proto_model_ac5eccb4ede5b877d6256cbbc2b9f4666}{effect\+End}} (void) const
\begin{DoxyCompactList}\small\item\em Get an iterator to the last \mbox{\hyperlink{class_effect_record}{Effect\+Record}}. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_a8d1f841c8f099cc2f124b8257c51d50f}{num\+Likely\+Trash}} (void) const
\begin{DoxyCompactList}\small\item\em Get the number of {\itshape likelytrash} locations. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \& \mbox{\hyperlink{class_proto_model_a1e6449c1c7d16d6ec396d29e58042cad}{get\+Likely\+Trash}} (int4 i) const
\begin{DoxyCompactList}\small\item\em Get the i-\/th {\itshape likelytrashh} location. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a1c0e6fe360413702b20cd04367dc477f}{possible\+Input\+Param}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size) const
\begin{DoxyCompactList}\small\item\em Does the given storage location make sense as an input parameter. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_aea2696911b81cc71cc68d927d7c02204}{possible\+Output\+Param}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size) const
\begin{DoxyCompactList}\small\item\em Does the given storage location make sense as a return value. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a6577cdf023ed6a660ba804e43e356b4e}{possible\+Input\+Param\+With\+Slot}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size, int4 \&slot, int4 \&slotsize) const
\begin{DoxyCompactList}\small\item\em Pass-\/back the slot and slot size for the given storage location as an input parameter. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_afd3283c9f718ce1e521186810f48ce6f}{possible\+Output\+Param\+With\+Slot}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size, int4 \&slot, int4 \&slotsize) const
\begin{DoxyCompactList}\small\item\em Pass-\/back the slot and slot size for the given storage location as a return value. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a8c0c20931a1fe2c0d3cf4fb3f8fe7c02}{unjustified\+Input\+Param}} (const \mbox{\hyperlink{class_address}{Address}} \&loc, int4 size, \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&res) const
\begin{DoxyCompactList}\small\item\em Check if the given storage location looks like an {\itshape unjustified} input parameter. \end{DoxyCompactList}\item 
\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} \mbox{\hyperlink{class_proto_model_a4fcf1b51c0ce470e353e798b9eaa8603}{assumed\+Input\+Extension}} (const \mbox{\hyperlink{class_address}{Address}} \&addr, int4 size, \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&res) const
\begin{DoxyCompactList}\small\item\em Get the type of extension and containing input parameter for the given storage. \end{DoxyCompactList}\item 
\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} \mbox{\hyperlink{class_proto_model_a74ad1cd29d07b30a4525049a6b2ee270}{assumed\+Output\+Extension}} (const \mbox{\hyperlink{class_address}{Address}} \&addr, int4 size, \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&res) const
\begin{DoxyCompactList}\small\item\em Get the type of extension and containing return value location for the given storage. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_addr_space}{Addr\+Space}} $\ast$ \mbox{\hyperlink{class_proto_model_a9918d9e7595d9f33f53bd9ffd3118f19}{get\+Spacebase}} (void) const
\begin{DoxyCompactList}\small\item\em Get the stack space associated with {\bfseries{this}} model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a9fd453910b4e750e3c67f26969c17001}{is\+Stack\+Grows\+Negative}} (void) const
\begin{DoxyCompactList}\small\item\em Return {\bfseries{true}} if the stack {\itshape grows} toward smaller addresses. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_aace107c2668bbd0091159f5c9e5a9042}{has\+This\+Pointer}} (void) const
\begin{DoxyCompactList}\small\item\em Is {\bfseries{this}} a model for (non-\/static) class methods. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_proto_model_a8699b4b61ebc7565dbfd7ec7ab600eca}{is\+Constructor}} (void) const
\begin{DoxyCompactList}\small\item\em Is {\bfseries{this}} model for class constructors. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_a0a6e71fa168f7af91d6b658516a61326}{get\+Max\+Input\+Delay}} (void) const
\begin{DoxyCompactList}\small\item\em Return the maximum heritage delay across all possible input parameters. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{class_proto_model_a6692a33595e306f23f23d98093a006bf}{get\+Max\+Output\+Delay}} (void) const
\begin{DoxyCompactList}\small\item\em Return the maximum heritage delay across all possible return values. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{class_proto_model_a580207b945d3734b6f1e6023b3ca2678}{is\+Merged}} (void) const
\begin{DoxyCompactList}\small\item\em Is {\bfseries{this}} a merged prototype model. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8}{restore\+Xml}} (const \mbox{\hyperlink{class_element}{Element}} $\ast$el)
\begin{DoxyCompactList}\small\item\em Restore {\bfseries{this}} model from an X\+ML stream. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static uint4 \mbox{\hyperlink{class_proto_model_aec744a55c36bed8f08fa923fad80df46}{lookup\+Effect}} (const vector$<$ \mbox{\hyperlink{class_effect_record}{Effect\+Record}} $>$ \&efflist, const \mbox{\hyperlink{class_address}{Address}} \&addr, int4 size)
\begin{DoxyCompactList}\small\item\em Look up an effect from the given \mbox{\hyperlink{class_effect_record}{Effect\+Record}} list. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_proto_model_a35178d22f44e8a5ab5fcb4d7c9caf25e}{Proto\+Model\+Merged}}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A {\bfseries{prototype}} {\bfseries{model\+:}} a model for passing parameters between functions. 

This encompasses both input parameters and return values. It attempts to describe the A\+BI, Application Binary Interface, of the processor or compiler. Any number of function prototypes (\mbox{\hyperlink{class_func_proto}{Func\+Proto}}) can be implemented under a {\bfseries{prototype}} {\bfseries{model}}, which represents a static rule set the compiler uses to decide\+:
\begin{DoxyItemize}
\item Storage locations for input parameters
\item Storage locations for return values
\item Expected side-\/effects of a function on other (non-\/parameter) registers and storage locations
\item Behavior of the stack and the stack pointer across function calls
\end{DoxyItemize}

Major analysis concerns are\+:
\begin{DoxyItemize}
\item Recovering function prototypes from data-\/flow information\+: \mbox{\hyperlink{class_proto_model_a7f6da17343cb12b0e798fe7211441c58}{derive\+Input\+Map()}} and \mbox{\hyperlink{class_proto_model_a463595607985ec774f3df35dfbd7ca94}{derive\+Output\+Map()}}
\item Calculating parameter storage locations given a function prototype\+: \mbox{\hyperlink{class_proto_model_a5c32e533f079fc91875ccd486f70f36e}{assign\+Parameter\+Storage()}}
\item Behavior of data-\/flow around call sites
\end{DoxyItemize}

A prototype model supports the concept of {\bfseries{extrapop}}, which is defined as the change in value of the stack pointer (or the number of bytes popped from the stack) across a call. This value is calculated starting from the point of the p-\/code C\+A\+LL or C\+A\+L\+L\+I\+ND op, when the stack parameters have already been pushed by the calling function. So {\itshape extrapop} only reflects changes made by the callee. 

Definition at line 547 of file fspec.\+hh.



\subsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_proto_model_ab532221dd4a9946b2dea90be44c79879}\label{class_proto_model_ab532221dd4a9946b2dea90be44c79879}} 
\subsubsection{\texorpdfstring{anonymous enum}{anonymous enum}}
{\footnotesize\ttfamily anonymous enum}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{extrapop\_unknown@{extrapop\_unknown}!ProtoModel@{ProtoModel}}\index{ProtoModel@{ProtoModel}!extrapop\_unknown@{extrapop\_unknown}}}\mbox{\Hypertarget{class_proto_model_ab532221dd4a9946b2dea90be44c79879ab0874d825448e7c731717fad59bbec92}\label{class_proto_model_ab532221dd4a9946b2dea90be44c79879ab0874d825448e7c731717fad59bbec92}} 
extrapop\+\_\+unknown&Reserved extrapop value meaning the function\textquotesingle{}s {\itshape extrapop} is unknown. \\
\hline

\end{DoxyEnumFields}


Definition at line 567 of file fspec.\+hh.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_proto_model_a4ef7db884a8c5bcdea92ed7b2d6a9ac0}\label{class_proto_model_a4ef7db884a8c5bcdea92ed7b2d6a9ac0}} 
\index{ProtoModel@{ProtoModel}!ProtoModel@{ProtoModel}}
\index{ProtoModel@{ProtoModel}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{ProtoModel()}{ProtoModel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Proto\+Model\+::\+Proto\+Model (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_architecture}{Architecture}} $\ast$}]{g }\end{DoxyParamCaption})}



\mbox{\hyperlink{class_constructor}{Constructor}} for use with \mbox{\hyperlink{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8}{restore\+Xml()}} 


\begin{DoxyParams}{Parameters}
{\em g} & is the \mbox{\hyperlink{class_architecture}{Architecture}} that will own the new prototype model \\
\hline
\end{DoxyParams}


Definition at line 1612 of file fspec.\+cc.

\mbox{\Hypertarget{class_proto_model_a6385c58ce2f155d13f506c64a7a03b11}\label{class_proto_model_a6385c58ce2f155d13f506c64a7a03b11}} 
\index{ProtoModel@{ProtoModel}!ProtoModel@{ProtoModel}}
\index{ProtoModel@{ProtoModel}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{ProtoModel()}{ProtoModel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Proto\+Model\+::\+Proto\+Model (\begin{DoxyParamCaption}\item[{const string \&}]{nm,  }\item[{const \mbox{\hyperlink{class_proto_model}{Proto\+Model}} \&}]{op2 }\end{DoxyParamCaption})}



Copy constructor changing the name. 

Everything is copied from the given prototype model except the name 
\begin{DoxyParams}{Parameters}
{\em nm} & is the new name for {\bfseries{this}} copy \\
\hline
{\em op2} & is the prototype model to copy \\
\hline
\end{DoxyParams}


Definition at line 1631 of file fspec.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{class_proto_model_a6385c58ce2f155d13f506c64a7a03b11_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_ae253f61258ac2ad8f165200d1737e7a3}\label{class_proto_model_ae253f61258ac2ad8f165200d1737e7a3}} 
\index{ProtoModel@{ProtoModel}!````~ProtoModel@{$\sim$ProtoModel}}
\index{````~ProtoModel@{$\sim$ProtoModel}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{$\sim$ProtoModel()}{~ProtoModel()}}
{\footnotesize\ttfamily Proto\+Model\+::$\sim$\+Proto\+Model (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Destructor. 



Definition at line 1658 of file fspec.\+cc.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_proto_model_a5c32e533f079fc91875ccd486f70f36e}\label{class_proto_model_a5c32e533f079fc91875ccd486f70f36e}} 
\index{ProtoModel@{ProtoModel}!assignParameterStorage@{assignParameterStorage}}
\index{assignParameterStorage@{assignParameterStorage}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{assignParameterStorage()}{assignParameterStorage()}}
{\footnotesize\ttfamily void Proto\+Model\+::assign\+Parameter\+Storage (\begin{DoxyParamCaption}\item[{const vector$<$ \mbox{\hyperlink{class_datatype}{Datatype}} $\ast$ $>$ \&}]{typelist,  }\item[{vector$<$ \mbox{\hyperlink{struct_parameter_pieces}{Parameter\+Pieces}} $>$ \&}]{res,  }\item[{bool}]{ignore\+Output\+Error }\end{DoxyParamCaption})}



Calculate input and output storage locations given a function prototype. 

The data-\/types of the function prototype are passed in as an ordered list, with the first data-\/type corresponding to the {\itshape return} {\itshape value} and all remaining data-\/types corresponding to the input parameters. Based on {\bfseries{this}} model, a storage location is selected for each (input and output) parameter and passed back to the caller. The passed back storage locations are ordered similarly, with the output storage as the first entry. The model has the option of inserting a {\itshape hidden} return value pointer in the input storage locations.

A {\bfseries{void}} return type is indicated by the formal T\+Y\+P\+E\+\_\+\+V\+O\+ID in the (either) list. If the model can\textquotesingle{}t map the specific output prototype, the caller has the option of whether an exception (\mbox{\hyperlink{struct_param_unassigned_error}{Param\+Unassigned\+Error}}) is thrown. If they choose not to throw, the unmapped return value is assumed to be {\itshape void}. 
\begin{DoxyParams}{Parameters}
{\em typelist} & is the list of data-\/types from the function prototype \\
\hline
{\em res} & will hold the storage locations for each parameter \\
\hline
{\em ignore\+Output\+Error} & is {\bfseries{true}} if problems assigning the output parameter are ignored \\
\hline
\end{DoxyParams}


Definition at line 1684 of file fspec.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a5c32e533f079fc91875ccd486f70f36e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a5c32e533f079fc91875ccd486f70f36e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a4fcf1b51c0ce470e353e798b9eaa8603}\label{class_proto_model_a4fcf1b51c0ce470e353e798b9eaa8603}} 
\index{ProtoModel@{ProtoModel}!assumedInputExtension@{assumedInputExtension}}
\index{assumedInputExtension@{assumedInputExtension}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{assumedInputExtension()}{assumedInputExtension()}}
{\footnotesize\ttfamily \mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} Proto\+Model\+::assumed\+Input\+Extension (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{addr,  }\item[{int4}]{size,  }\item[{\mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&}]{res }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the type of extension and containing input parameter for the given storage. 

If the given storage is properly contained within a normal parameter and the model typically extends a small value into the full container, pass back the full container and the type of extension. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the starting address of the given storage \\
\hline
{\em size} & is the number of bytes in the given storage \\
\hline
{\em res} & is the parameter storage to pass back \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the extension operator (I\+N\+T\+\_\+\+Z\+E\+XT I\+N\+T\+\_\+\+S\+E\+XT) or I\+N\+T\+\_\+\+C\+O\+PY if there is no extension. I\+N\+T\+\_\+\+P\+I\+E\+CE indicates the extension is determined by the specific prototype. 
\end{DoxyReturn}


Definition at line 703 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a4fcf1b51c0ce470e353e798b9eaa8603_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a4fcf1b51c0ce470e353e798b9eaa8603_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a74ad1cd29d07b30a4525049a6b2ee270}\label{class_proto_model_a74ad1cd29d07b30a4525049a6b2ee270}} 
\index{ProtoModel@{ProtoModel}!assumedOutputExtension@{assumedOutputExtension}}
\index{assumedOutputExtension@{assumedOutputExtension}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{assumedOutputExtension()}{assumedOutputExtension()}}
{\footnotesize\ttfamily \mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} Proto\+Model\+::assumed\+Output\+Extension (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{addr,  }\item[{int4}]{size,  }\item[{\mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&}]{res }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the type of extension and containing return value location for the given storage. 

If the given storage is properly contained within a normal return value location and the model typically extends a small value into the full container, pass back the full container and the type of extension. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the starting address of the given storage \\
\hline
{\em size} & is the number of bytes in the given storage \\
\hline
{\em res} & is the parameter storage to pass back \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the extension operator (I\+N\+T\+\_\+\+Z\+E\+XT I\+N\+T\+\_\+\+S\+E\+XT) or I\+N\+T\+\_\+\+C\+O\+PY if there is no extension. I\+N\+T\+\_\+\+P\+I\+E\+CE indicates the extension is determined by the specific prototype. 
\end{DoxyReturn}


Definition at line 716 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a74ad1cd29d07b30a4525049a6b2ee270_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a74ad1cd29d07b30a4525049a6b2ee270_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a06031cb84a876e36a3648362c4af8662}\label{class_proto_model_a06031cb84a876e36a3648362c4af8662}} 
\index{ProtoModel@{ProtoModel}!checkInputJoin@{checkInputJoin}}
\index{checkInputJoin@{checkInputJoin}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{checkInputJoin()}{checkInputJoin()}}
{\footnotesize\ttfamily bool Proto\+Model\+::check\+Input\+Join (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{hiaddr,  }\item[{int4}]{hisize,  }\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loaddr,  }\item[{int4}]{losize }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if the given two input storage locations can represent a single logical parameter. 

Within the conventions of this model, do the two (hi/lo) locations represent consecutive input parameter locations that can be replaced by a single logical parameter. 
\begin{DoxyParams}{Parameters}
{\em hiaddr} & is the address of the most significant part of the value \\
\hline
{\em hisize} & is the size of the most significant part in bytes \\
\hline
{\em loaddr} & is the address of the least significant part of the value \\
\hline
{\em losize} & is the size of the least significant part in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the two pieces can be joined 
\end{DoxyReturn}


Definition at line 606 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a06031cb84a876e36a3648362c4af8662_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a06031cb84a876e36a3648362c4af8662_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a6ddc6e7d218491b657d1f5e5bb997592}\label{class_proto_model_a6ddc6e7d218491b657d1f5e5bb997592}} 
\index{ProtoModel@{ProtoModel}!checkInputSplit@{checkInputSplit}}
\index{checkInputSplit@{checkInputSplit}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{checkInputSplit()}{checkInputSplit()}}
{\footnotesize\ttfamily bool Proto\+Model\+::check\+Input\+Split (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size,  }\item[{int4}]{splitpoint }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if it makes sense to split a single storage location into two input parameters. 

A storage location and split point is provided, implying two new storage locations. Does {\bfseries{this}} model allow these locations to be considered separate parameters. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of provided storage location \\
\hline
{\em size} & is the size of the location in bytes \\
\hline
{\em splitpoint} & is the number of bytes to consider in the first (in address order) piece \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the storage location can be split 
\end{DoxyReturn}


Definition at line 629 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6ddc6e7d218491b657d1f5e5bb997592_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6ddc6e7d218491b657d1f5e5bb997592_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a0e0ae91c9fa12f548418c469f63c9d1d}\label{class_proto_model_a0e0ae91c9fa12f548418c469f63c9d1d}} 
\index{ProtoModel@{ProtoModel}!checkOutputJoin@{checkOutputJoin}}
\index{checkOutputJoin@{checkOutputJoin}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{checkOutputJoin()}{checkOutputJoin()}}
{\footnotesize\ttfamily bool Proto\+Model\+::check\+Output\+Join (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{hiaddr,  }\item[{int4}]{hisize,  }\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loaddr,  }\item[{int4}]{losize }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if the given two output storage locations can represent a single logical return value. 

Within the conventions of this model, do the two (hi/lo) locations represent consecutive locations that can be replaced by a single logical return value. 
\begin{DoxyParams}{Parameters}
{\em hiaddr} & is the address of the most significant part of the value \\
\hline
{\em hisize} & is the size of the most significant part in bytes \\
\hline
{\em loaddr} & is the address of the least significant part of the value \\
\hline
{\em losize} & is the size of the least significant part in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the two pieces can be joined 
\end{DoxyReturn}


Definition at line 618 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a0e0ae91c9fa12f548418c469f63c9d1d_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a7f6da17343cb12b0e798fe7211441c58}\label{class_proto_model_a7f6da17343cb12b0e798fe7211441c58}} 
\index{ProtoModel@{ProtoModel}!deriveInputMap@{deriveInputMap}}
\index{deriveInputMap@{deriveInputMap}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{deriveInputMap()}{deriveInputMap()}}
{\footnotesize\ttfamily void Proto\+Model\+::derive\+Input\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_param_active}{Param\+Active}} $\ast$}]{active }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Given a list of input {\itshape trials}, derive the most likely input prototype. 

Trials are sorted and marked as {\itshape used} or not. 
\begin{DoxyParams}{Parameters}
{\em active} & is the collection of \mbox{\hyperlink{class_varnode}{Varnode}} input trials \\
\hline
\end{DoxyParams}


Definition at line 585 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a7f6da17343cb12b0e798fe7211441c58_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a7f6da17343cb12b0e798fe7211441c58_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a463595607985ec774f3df35dfbd7ca94}\label{class_proto_model_a463595607985ec774f3df35dfbd7ca94}} 
\index{ProtoModel@{ProtoModel}!deriveOutputMap@{deriveOutputMap}}
\index{deriveOutputMap@{deriveOutputMap}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{deriveOutputMap()}{deriveOutputMap()}}
{\footnotesize\ttfamily void Proto\+Model\+::derive\+Output\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_param_active}{Param\+Active}} $\ast$}]{active }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Given a list of output {\itshape trials}, derive the most likely output prototype. 

One trial (at most) is marked {\itshape used} and moved to the front of the list 
\begin{DoxyParams}{Parameters}
{\em active} & is the collection of output trials \\
\hline
\end{DoxyParams}


Definition at line 592 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a463595607985ec774f3df35dfbd7ca94_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a463595607985ec774f3df35dfbd7ca94_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a5c9fa95940e32b03d475257ca177cfaa}\label{class_proto_model_a5c9fa95940e32b03d475257ca177cfaa}} 
\index{ProtoModel@{ProtoModel}!effectBegin@{effectBegin}}
\index{effectBegin@{effectBegin}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{effectBegin()}{effectBegin()}}
{\footnotesize\ttfamily vector$<$\mbox{\hyperlink{class_effect_record}{Effect\+Record}}$>$\+::const\+\_\+iterator Proto\+Model\+::effect\+Begin (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get an iterator to the first \mbox{\hyperlink{class_effect_record}{Effect\+Record}}. 



Definition at line 634 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a5c9fa95940e32b03d475257ca177cfaa_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_ac5eccb4ede5b877d6256cbbc2b9f4666}\label{class_proto_model_ac5eccb4ede5b877d6256cbbc2b9f4666}} 
\index{ProtoModel@{ProtoModel}!effectEnd@{effectEnd}}
\index{effectEnd@{effectEnd}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{effectEnd()}{effectEnd()}}
{\footnotesize\ttfamily vector$<$\mbox{\hyperlink{class_effect_record}{Effect\+Record}}$>$\+::const\+\_\+iterator Proto\+Model\+::effect\+End (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get an iterator to the last \mbox{\hyperlink{class_effect_record}{Effect\+Record}}. 



Definition at line 635 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_ac5eccb4ede5b877d6256cbbc2b9f4666_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a256b9f054603fd6d166fdf86689467bf}\label{class_proto_model_a256b9f054603fd6d166fdf86689467bf}} 
\index{ProtoModel@{ProtoModel}!getArch@{getArch}}
\index{getArch@{getArch}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getArch()}{getArch()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_architecture}{Architecture}}$\ast$ Proto\+Model\+::get\+Arch (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the owning \mbox{\hyperlink{class_architecture}{Architecture}}. 



Definition at line 574 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a256b9f054603fd6d166fdf86689467bf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a640ae87320b6d6781639643057e61e1d}\label{class_proto_model_a640ae87320b6d6781639643057e61e1d}} 
\index{ProtoModel@{ProtoModel}!getExtraPop@{getExtraPop}}
\index{getExtraPop@{getExtraPop}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getExtraPop()}{getExtraPop()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::get\+Extra\+Pop (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the stack-\/pointer {\itshape extrapop} for {\bfseries{this}} model. 



Definition at line 576 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a640ae87320b6d6781639643057e61e1d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_af505f8d493ab0dcefca9e94941c13658}\label{class_proto_model_af505f8d493ab0dcefca9e94941c13658}} 
\index{ProtoModel@{ProtoModel}!getInjectUponEntry@{getInjectUponEntry}}
\index{getInjectUponEntry@{getInjectUponEntry}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getInjectUponEntry()}{getInjectUponEntry()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::get\+Inject\+Upon\+Entry (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the inject {\itshape uponentry} id. 



Definition at line 578 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_af505f8d493ab0dcefca9e94941c13658_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a2e8994c68acebcf5c0278d86be39a530}\label{class_proto_model_a2e8994c68acebcf5c0278d86be39a530}} 
\index{ProtoModel@{ProtoModel}!getInjectUponReturn@{getInjectUponReturn}}
\index{getInjectUponReturn@{getInjectUponReturn}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getInjectUponReturn()}{getInjectUponReturn()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::get\+Inject\+Upon\+Return (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the inject {\itshape uponreturn} id. 



Definition at line 579 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a2e8994c68acebcf5c0278d86be39a530_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a1e6449c1c7d16d6ec396d29e58042cad}\label{class_proto_model_a1e6449c1c7d16d6ec396d29e58042cad}} 
\index{ProtoModel@{ProtoModel}!getLikelyTrash@{getLikelyTrash}}
\index{getLikelyTrash@{getLikelyTrash}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getLikelyTrash()}{getLikelyTrash()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}}\& Proto\+Model\+::get\+Likely\+Trash (\begin{DoxyParamCaption}\item[{int4}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the i-\/th {\itshape likelytrashh} location. 



Definition at line 637 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a1e6449c1c7d16d6ec396d29e58042cad_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a4736d007016235f93ae81100f8312e26}\label{class_proto_model_a4736d007016235f93ae81100f8312e26}} 
\index{ProtoModel@{ProtoModel}!getLocalRange@{getLocalRange}}
\index{getLocalRange@{getLocalRange}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getLocalRange()}{getLocalRange()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_range_list}{Range\+List}}\& Proto\+Model\+::get\+Local\+Range (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the range of (possible) local stack variables. 



Definition at line 632 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a4736d007016235f93ae81100f8312e26_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a0a6e71fa168f7af91d6b658516a61326}\label{class_proto_model_a0a6e71fa168f7af91d6b658516a61326}} 
\index{ProtoModel@{ProtoModel}!getMaxInputDelay@{getMaxInputDelay}}
\index{getMaxInputDelay@{getMaxInputDelay}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getMaxInputDelay()}{getMaxInputDelay()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::get\+Max\+Input\+Delay (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the maximum heritage delay across all possible input parameters. 

Depending on the address space, data-\/flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that all parameters have data-\/flow info. \begin{DoxyReturn}{Returns}
the maximum number of passes across all input parameters in {\bfseries{this}} model 
\end{DoxyReturn}


Definition at line 730 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a0a6e71fa168f7af91d6b658516a61326_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a0a6e71fa168f7af91d6b658516a61326_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a6692a33595e306f23f23d98093a006bf}\label{class_proto_model_a6692a33595e306f23f23d98093a006bf}} 
\index{ProtoModel@{ProtoModel}!getMaxOutputDelay@{getMaxOutputDelay}}
\index{getMaxOutputDelay@{getMaxOutputDelay}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getMaxOutputDelay()}{getMaxOutputDelay()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::get\+Max\+Output\+Delay (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the maximum heritage delay across all possible return values. 

Depending on the address space, data-\/flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that any return value has data-\/flow info. \begin{DoxyReturn}{Returns}
the maximum number of passes across all output parameters in {\bfseries{this}} model 
\end{DoxyReturn}


Definition at line 738 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6692a33595e306f23f23d98093a006bf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6692a33595e306f23f23d98093a006bf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a19f8d9a9dbc7fb8d52aa180410cddc8b}\label{class_proto_model_a19f8d9a9dbc7fb8d52aa180410cddc8b}} 
\index{ProtoModel@{ProtoModel}!getName@{getName}}
\index{getName@{getName}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getName()}{getName()}}
{\footnotesize\ttfamily const string\& Proto\+Model\+::get\+Name (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the name of the prototype model. 



Definition at line 573 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a19f8d9a9dbc7fb8d52aa180410cddc8b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a2a83c006b588fad0b0842c6f9862e66b}\label{class_proto_model_a2a83c006b588fad0b0842c6f9862e66b}} 
\index{ProtoModel@{ProtoModel}!getParamRange@{getParamRange}}
\index{getParamRange@{getParamRange}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getParamRange()}{getParamRange()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_range_list}{Range\+List}}\& Proto\+Model\+::get\+Param\+Range (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the range of (possible) stack parameters. 



Definition at line 633 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a2a83c006b588fad0b0842c6f9862e66b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a9918d9e7595d9f33f53bd9ffd3118f19}\label{class_proto_model_a9918d9e7595d9f33f53bd9ffd3118f19}} 
\index{ProtoModel@{ProtoModel}!getSpacebase@{getSpacebase}}
\index{getSpacebase@{getSpacebase}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{getSpacebase()}{getSpacebase()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_addr_space}{Addr\+Space}}$\ast$ Proto\+Model\+::get\+Spacebase (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the stack space associated with {\bfseries{this}} model. 



Definition at line 719 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a9918d9e7595d9f33f53bd9ffd3118f19_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a9918d9e7595d9f33f53bd9ffd3118f19_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a5bd9f07bc75fc5f2497f1d4de685a8cf}\label{class_proto_model_a5bd9f07bc75fc5f2497f1d4de685a8cf}} 
\index{ProtoModel@{ProtoModel}!hasEffect@{hasEffect}}
\index{hasEffect@{hasEffect}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{hasEffect()}{hasEffect()}}
{\footnotesize\ttfamily uint4 Proto\+Model\+::has\+Effect (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{addr,  }\item[{int4}]{size }\end{DoxyParamCaption}) const}



Determine side-\/effect of {\bfseries{this}} on the given memory range. 

The model is searched for an \mbox{\hyperlink{class_effect_record}{Effect\+Record}} matching the given range and the effect type is returned. If there is no \mbox{\hyperlink{class_effect_record}{Effect\+Record}} or the effect generally isn\textquotesingle{}t known, \mbox{\hyperlink{class_effect_record_a9a77875d39274819c56d6e4df5f23ab0a02697f294ad0f4b53317da792c577a10}{Effect\+Record\+::unknown\+\_\+effect}} is returned. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the starting address of the given memory range \\
\hline
{\em size} & is the number of bytes in the given range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_effect_record}{Effect\+Record}} type 
\end{DoxyReturn}


Definition at line 1744 of file fspec.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a5bd9f07bc75fc5f2497f1d4de685a8cf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a5bd9f07bc75fc5f2497f1d4de685a8cf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_aace107c2668bbd0091159f5c9e5a9042}\label{class_proto_model_aace107c2668bbd0091159f5c9e5a9042}} 
\index{ProtoModel@{ProtoModel}!hasThisPointer@{hasThisPointer}}
\index{hasThisPointer@{hasThisPointer}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{hasThisPointer()}{hasThisPointer()}}
{\footnotesize\ttfamily bool Proto\+Model\+::has\+This\+Pointer (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Is {\bfseries{this}} a model for (non-\/static) class methods. 



Definition at line 721 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_aace107c2668bbd0091159f5c9e5a9042_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a8699b4b61ebc7565dbfd7ec7ab600eca}\label{class_proto_model_a8699b4b61ebc7565dbfd7ec7ab600eca}} 
\index{ProtoModel@{ProtoModel}!isConstructor@{isConstructor}}
\index{isConstructor@{isConstructor}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{isConstructor()}{isConstructor()}}
{\footnotesize\ttfamily bool Proto\+Model\+::is\+Constructor (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Is {\bfseries{this}} model for class constructors. 



Definition at line 722 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8699b4b61ebc7565dbfd7ec7ab600eca_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a580207b945d3734b6f1e6023b3ca2678}\label{class_proto_model_a580207b945d3734b6f1e6023b3ca2678}} 
\index{ProtoModel@{ProtoModel}!isMerged@{isMerged}}
\index{isMerged@{isMerged}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{isMerged()}{isMerged()}}
{\footnotesize\ttfamily virtual bool Proto\+Model\+::is\+Merged (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Is {\bfseries{this}} a merged prototype model. 



Reimplemented in \mbox{\hyperlink{class_proto_model_merged_aea3dceb1497499800015607bbfd2d863}{Proto\+Model\+Merged}}.



Definition at line 740 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a580207b945d3734b6f1e6023b3ca2678_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a9fd453910b4e750e3c67f26969c17001}\label{class_proto_model_a9fd453910b4e750e3c67f26969c17001}} 
\index{ProtoModel@{ProtoModel}!isStackGrowsNegative@{isStackGrowsNegative}}
\index{isStackGrowsNegative@{isStackGrowsNegative}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{isStackGrowsNegative()}{isStackGrowsNegative()}}
{\footnotesize\ttfamily bool Proto\+Model\+::is\+Stack\+Grows\+Negative (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return {\bfseries{true}} if the stack {\itshape grows} toward smaller addresses. 



Definition at line 720 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a9fd453910b4e750e3c67f26969c17001_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_aec744a55c36bed8f08fa923fad80df46}\label{class_proto_model_aec744a55c36bed8f08fa923fad80df46}} 
\index{ProtoModel@{ProtoModel}!lookupEffect@{lookupEffect}}
\index{lookupEffect@{lookupEffect}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{lookupEffect()}{lookupEffect()}}
{\footnotesize\ttfamily uint4 Proto\+Model\+::lookup\+Effect (\begin{DoxyParamCaption}\item[{const vector$<$ \mbox{\hyperlink{class_effect_record}{Effect\+Record}} $>$ \&}]{efflist,  }\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{addr,  }\item[{int4}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Look up an effect from the given \mbox{\hyperlink{class_effect_record}{Effect\+Record}} list. 

If a given memory range matches an \mbox{\hyperlink{class_effect_record}{Effect\+Record}}, return the effect type. Otherwise return \mbox{\hyperlink{class_effect_record_a9a77875d39274819c56d6e4df5f23ab0a02697f294ad0f4b53317da792c577a10}{Effect\+Record\+::unknown\+\_\+effect}} 
\begin{DoxyParams}{Parameters}
{\em efflist} & is the list of Effect\+Records which must be sorted \\
\hline
{\em addr} & is the starting address of the given memory range \\
\hline
{\em size} & is the number of bytes in the memory range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_effect_record}{Effect\+Record}} type 
\end{DoxyReturn}


Definition at line 1713 of file fspec.\+cc.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_aec744a55c36bed8f08fa923fad80df46_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a8d1f841c8f099cc2f124b8257c51d50f}\label{class_proto_model_a8d1f841c8f099cc2f124b8257c51d50f}} 
\index{ProtoModel@{ProtoModel}!numLikelyTrash@{numLikelyTrash}}
\index{numLikelyTrash@{numLikelyTrash}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{numLikelyTrash()}{numLikelyTrash()}}
{\footnotesize\ttfamily int4 Proto\+Model\+::num\+Likely\+Trash (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of {\itshape likelytrash} locations. 



Definition at line 636 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8d1f841c8f099cc2f124b8257c51d50f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a1c0e6fe360413702b20cd04367dc477f}\label{class_proto_model_a1c0e6fe360413702b20cd04367dc477f}} 
\index{ProtoModel@{ProtoModel}!possibleInputParam@{possibleInputParam}}
\index{possibleInputParam@{possibleInputParam}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{possibleInputParam()}{possibleInputParam()}}
{\footnotesize\ttfamily bool Proto\+Model\+::possible\+Input\+Param (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Does the given storage location make sense as an input parameter. 

Within {\bfseries{this}} model, decide if the storage location can be considered an input parameter. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of the storage location \\
\hline
{\em size} & is the number of bytes in the storage location \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the location can be a parameter 
\end{DoxyReturn}


Definition at line 645 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a1c0e6fe360413702b20cd04367dc477f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a1c0e6fe360413702b20cd04367dc477f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a6577cdf023ed6a660ba804e43e356b4e}\label{class_proto_model_a6577cdf023ed6a660ba804e43e356b4e}} 
\index{ProtoModel@{ProtoModel}!possibleInputParamWithSlot@{possibleInputParamWithSlot}}
\index{possibleInputParamWithSlot@{possibleInputParamWithSlot}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{possibleInputParamWithSlot()}{possibleInputParamWithSlot()}}
{\footnotesize\ttfamily bool Proto\+Model\+::possible\+Input\+Param\+With\+Slot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size,  }\item[{int4 \&}]{slot,  }\item[{int4 \&}]{slotsize }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass-\/back the slot and slot size for the given storage location as an input parameter. 

This checks if the given storage location acts as an input parameter in {\bfseries{this}} model and passes back the number of slots that it occupies. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of the storage location \\
\hline
{\em size} & is the number of bytes in the storage location \\
\hline
{\em slot} & if the {\itshape slot} number to pass back \\
\hline
{\em slotsize} & is the number of consumed slots to pass back \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the location can be a parameter 
\end{DoxyReturn}


Definition at line 666 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6577cdf023ed6a660ba804e43e356b4e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a6577cdf023ed6a660ba804e43e356b4e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_aea2696911b81cc71cc68d927d7c02204}\label{class_proto_model_aea2696911b81cc71cc68d927d7c02204}} 
\index{ProtoModel@{ProtoModel}!possibleOutputParam@{possibleOutputParam}}
\index{possibleOutputParam@{possibleOutputParam}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{possibleOutputParam()}{possibleOutputParam()}}
{\footnotesize\ttfamily bool Proto\+Model\+::possible\+Output\+Param (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Does the given storage location make sense as a return value. 

Within {\bfseries{this}} model, decide if the storage location can be considered an output parameter. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of the storage location \\
\hline
{\em size} & is the number of bytes in the storage location \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the location can be a parameter 
\end{DoxyReturn}


Definition at line 654 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_aea2696911b81cc71cc68d927d7c02204_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_aea2696911b81cc71cc68d927d7c02204_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_afd3283c9f718ce1e521186810f48ce6f}\label{class_proto_model_afd3283c9f718ce1e521186810f48ce6f}} 
\index{ProtoModel@{ProtoModel}!possibleOutputParamWithSlot@{possibleOutputParamWithSlot}}
\index{possibleOutputParamWithSlot@{possibleOutputParamWithSlot}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{possibleOutputParamWithSlot()}{possibleOutputParamWithSlot()}}
{\footnotesize\ttfamily bool Proto\+Model\+::possible\+Output\+Param\+With\+Slot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size,  }\item[{int4 \&}]{slot,  }\item[{int4 \&}]{slotsize }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass-\/back the slot and slot size for the given storage location as a return value. 

This checks if the given storage location acts as an output parameter in {\bfseries{this}} model and passes back the number of slots that it occupies. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of the storage location \\
\hline
{\em size} & is the number of bytes in the storage location \\
\hline
{\em slot} & if the {\itshape slot} number to pass back \\
\hline
{\em slotsize} & is the number of consumed slots to pass back \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the location can be a parameter 
\end{DoxyReturn}


Definition at line 678 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_afd3283c9f718ce1e521186810f48ce6f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_afd3283c9f718ce1e521186810f48ce6f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8}\label{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8}} 
\index{ProtoModel@{ProtoModel}!restoreXml@{restoreXml}}
\index{restoreXml@{restoreXml}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{restoreXml()}{restoreXml()}}
{\footnotesize\ttfamily void Proto\+Model\+::restore\+Xml (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_element}{Element}} $\ast$}]{el }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Restore {\bfseries{this}} model from an X\+ML stream. 

Read in details about {\bfseries{this}} model from a $<$prototype$>$ tag 
\begin{DoxyParams}{Parameters}
{\em el} & is the $<$prototype$>$ element \\
\hline
\end{DoxyParams}


Reimplemented in \mbox{\hyperlink{class_proto_model_merged_a1c80c617c086b0edacb483f8315d12e9}{Proto\+Model\+Merged}}.



Definition at line 1752 of file fspec.\+cc.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8fe30abbc7fe1c709b1b8fe9c81803b8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a42eb0adf6bb66f15bbbde19c02c931ca}\label{class_proto_model_a42eb0adf6bb66f15bbbde19c02c931ca}} 
\index{ProtoModel@{ProtoModel}!setExtraPop@{setExtraPop}}
\index{setExtraPop@{setExtraPop}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{setExtraPop()}{setExtraPop()}}
{\footnotesize\ttfamily void Proto\+Model\+::set\+Extra\+Pop (\begin{DoxyParamCaption}\item[{int4}]{ep }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the stack-\/pointer {\itshape extrapop}. 



Definition at line 577 of file fspec.\+hh.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a42eb0adf6bb66f15bbbde19c02c931ca_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_proto_model_a8c0c20931a1fe2c0d3cf4fb3f8fe7c02}\label{class_proto_model_a8c0c20931a1fe2c0d3cf4fb3f8fe7c02}} 
\index{ProtoModel@{ProtoModel}!unjustifiedInputParam@{unjustifiedInputParam}}
\index{unjustifiedInputParam@{unjustifiedInputParam}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{unjustifiedInputParam()}{unjustifiedInputParam()}}
{\footnotesize\ttfamily bool Proto\+Model\+::unjustified\+Input\+Param (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_address}{Address}} \&}]{loc,  }\item[{int4}]{size,  }\item[{\mbox{\hyperlink{struct_varnode_data}{Varnode\+Data}} \&}]{res }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if the given storage location looks like an {\itshape unjustified} input parameter. 

The storage for a value may be contained in a normal parameter location but be unjustified within that container, i.\+e. the least significant bytes are not being used. If this is the case, pass back the full parameter location and return {\bfseries{true}}. 
\begin{DoxyParams}{Parameters}
{\em loc} & is the starting address of the given storage \\
\hline
{\em size} & is the number of bytes in the given storage \\
\hline
{\em res} & is the full parameter storage to pass back \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the given storage is unjustified within its parameter container 
\end{DoxyReturn}


Definition at line 690 of file fspec.\+hh.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8c0c20931a1fe2c0d3cf4fb3f8fe7c02_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_proto_model_a8c0c20931a1fe2c0d3cf4fb3f8fe7c02_icgraph}
\end{center}
\end{figure}


\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_proto_model_a35178d22f44e8a5ab5fcb4d7c9caf25e}\label{class_proto_model_a35178d22f44e8a5ab5fcb4d7c9caf25e}} 
\index{ProtoModel@{ProtoModel}!ProtoModelMerged@{ProtoModelMerged}}
\index{ProtoModelMerged@{ProtoModelMerged}!ProtoModel@{ProtoModel}}
\subsubsection{\texorpdfstring{ProtoModelMerged}{ProtoModelMerged}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{class_proto_model_merged}{Proto\+Model\+Merged}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 548 of file fspec.\+hh.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
F\+:/re/ghidra\+\_\+sourcecode/ghidra/\+Ghidra/\+Features/\+Decompiler/src/decompile/cpp/\mbox{\hyperlink{fspec_8hh}{fspec.\+hh}}\item 
F\+:/re/ghidra\+\_\+sourcecode/ghidra/\+Ghidra/\+Features/\+Decompiler/src/decompile/cpp/\mbox{\hyperlink{fspec_8cc}{fspec.\+cc}}\end{DoxyCompactItemize}
