.TH "ParamListStandard" 3 "Sun Apr 14 2019" "decompile" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ParamListStandard \- A standard model for parameters as an ordered list of storage resources\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fspec\&.hh>\fP
.PP
Inherits \fBParamList\fP\&.
.PP
Inherited by \fBParamListMerged\fP, \fBParamListRegister\fP, and \fBParamListStandardOut\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBParamListStandard\fP (void)"
.br
.RI "Construct for use with \fBrestoreXml()\fP "
.ti -1c
.RI "\fBParamListStandard\fP (const \fBParamListStandard\fP &op2)"
.br
.RI "Copy constructor\&. "
.ti -1c
.RI "const vector< \fBParamEntry\fP > & \fBgetEntry\fP (void) const"
.br
.RI "Get the list of parameter entries\&. "
.ti -1c
.RI "virtual uint4 \fBgetType\fP (void) const"
.br
.RI "Get the type of parameter list\&. "
.ti -1c
.RI "virtual void \fBassignMap\fP (const vector< \fBDatatype\fP * > &proto, bool isinput, \fBTypeFactory\fP &typefactory, vector< \fBParameterPieces\fP > &res) const"
.br
.RI "Given list of data-types, map the list positions to storage locations\&. "
.ti -1c
.RI "virtual void \fBfillinMap\fP (\fBParamActive\fP *active) const"
.br
.RI "Given an unordered list of storage locations, calculate a function prototype\&. "
.ti -1c
.RI "virtual bool \fBcheckJoin\fP (const \fBAddress\fP &hiaddr, int4 hisize, const \fBAddress\fP &loaddr, int4 losize) const"
.br
.RI "Check if the given two storage locations can represent a single logical parameter\&. "
.ti -1c
.RI "virtual bool \fBcheckSplit\fP (const \fBAddress\fP &loc, int4 size, int4 splitpoint) const"
.br
.RI "Check if it makes sense to split a single storage location into two parameters\&. "
.ti -1c
.RI "virtual bool \fBpossibleParam\fP (const \fBAddress\fP &loc, int4 size) const"
.br
.RI "Does the given storage location make sense as a parameter\&. "
.ti -1c
.RI "virtual bool \fBpossibleParamWithSlot\fP (const \fBAddress\fP &loc, int4 size, int4 &slot, int4 &slotsize) const"
.br
.RI "Pass-back the slot and slot size for the given storage location as a parameter\&. "
.ti -1c
.RI "virtual bool \fBunjustifiedContainer\fP (const \fBAddress\fP &loc, int4 size, \fBVarnodeData\fP &res) const"
.br
.RI "Check if the given storage location looks like an \fIunjustified\fP parameter\&. "
.ti -1c
.RI "virtual \fBOpCode\fP \fBassumedExtension\fP (const \fBAddress\fP &addr, int4 size, \fBVarnodeData\fP &res) const"
.br
.RI "Get the type of extension and containing parameter for the given storage\&. "
.ti -1c
.RI "virtual \fBAddrSpace\fP * \fBgetSpacebase\fP (void) const"
.br
.RI "Get the address space associated with any stack based parameters in \fBthis\fP list\&. "
.ti -1c
.RI "virtual void \fBgetRangeList\fP (\fBAddrSpace\fP *spc, \fBRangeList\fP &res) const"
.br
.RI "For a given address space, collect all the parameter locations within that space\&. "
.ti -1c
.RI "virtual int4 \fBgetMaxDelay\fP (void) const"
.br
.RI "Return the maximum heritage delay across all possible parameters\&. "
.ti -1c
.RI "virtual void \fBrestoreXml\fP (const \fBElement\fP *el, const \fBAddrSpaceManager\fP *manage, vector< \fBEffectRecord\fP > &effectlist, bool normalstack)"
.br
.RI "Restore the model from an XML stream\&. "
.ti -1c
.RI "virtual \fBParamList\fP * \fBclone\fP (void) const"
.br
.RI "Clone this parameter list model\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "int4 \fBfindEntry\fP (const \fBAddress\fP &loc, int4 size) const"
.br
.RI "Given storage location find matching \fBParamEntry\fP\&. "
.ti -1c
.RI "\fBAddress\fP \fBassignAddress\fP (const \fBDatatype\fP *tp, vector< int4 > &status) const"
.br
.RI "Assign storage for given parameter data-type\&. "
.ti -1c
.RI "void \fBbuildTrialMap\fP (\fBParamActive\fP *active) const"
.br
.RI "Build map from parameter trials to model ParamEntrys\&. "
.ti -1c
.RI "void \fBseparateFloat\fP (\fBParamActive\fP *active, int4 &floatstart, int4 &floatstop, int4 &start, int4 &stop) const"
.br
.RI "Calculate the range of floating-point entries within a given set of parameter \fItrials\fP\&. "
.ti -1c
.RI "void \fBforceExclusionGroup\fP (\fBParamActive\fP *active) const"
.br
.RI "Enforce exclusion rules for the given set of parameter trials\&. "
.ti -1c
.RI "void \fBforceNoUse\fP (\fBParamActive\fP *active, int4 start, int4 stop) const"
.br
.RI "Mark every trial above the first 'definitely not used' as \fIinactive\fP\&. "
.ti -1c
.RI "void \fBforceInactiveChain\fP (\fBParamActive\fP *active, int4 maxchain, int4 start, int4 stop) const"
.br
.RI "Enforce rules about chains of inactive slots\&. "
.ti -1c
.RI "void \fBcalcDelay\fP (void)"
.br
.RI "Calculate the maximum heritage delay for any potential parameter in this list\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "int4 \fBnumgroup\fP"
.br
.RI "Number of \fIgroups\fP in this parameter convention\&. "
.ti -1c
.RI "int4 \fBmaxdelay\fP"
.br
.RI "Maximum heritage delay across all parameters\&. "
.ti -1c
.RI "int4 \fBpointermax\fP"
.br
.RI "If non-zero, maximum size of a data-type before converting to a pointer\&. "
.ti -1c
.RI "bool \fBthisbeforeret\fP"
.br
.RI "Does a \fBthis\fP parameter come before a hidden return parameter\&. "
.ti -1c
.RI "int4 \fBnonfloatgroup\fP"
.br
.RI "Group of first entry which is not marked float\&. "
.ti -1c
.RI "vector< \fBParamEntry\fP > \fBentry\fP"
.br
.RI "The ordered list of parameter entries\&. "
.ti -1c
.RI "\fBAddrSpace\fP * \fBspacebase\fP"
.br
.RI "\fBAddress\fP space containing relative offset parameters\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
A standard model for parameters as an ordered list of storage resources\&. 

This is a configurable model for passing (input) parameters as a list to a function\&. The model allows 1 or more resource lists based on data-type, either TYPE_UNKNOWN for general purpose or TYPE_FLOAT for floating-point registers\&. Within a resource list, any number of parameters can be used but they must come starting at the beginning of the list with no \fIholes\fP (skipped resources)\&. A resource list can include (at the end) \fIstack\fP parameters that are allocated based on an alignment\&. Optionally, the model supports converting data-types larger than a specified size to pointers within the parameter list\&. 
.PP
Definition at line 429 of file fspec\&.hh\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ParamListStandard::ParamListStandard (void)\fC [inline]\fP"

.PP
Construct for use with \fBrestoreXml()\fP 
.PP
Definition at line 447 of file fspec\&.hh\&.
.SS "ParamListStandard::ParamListStandard (const \fBParamListStandard\fP & op2)"

.PP
Copy constructor\&. 
.PP
Definition at line 403 of file fspec\&.cc\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBAddress\fP ParamListStandard::assignAddress (const \fBDatatype\fP * tp, vector< int4 > & status) const\fC [protected]\fP"

.PP
Assign storage for given parameter data-type\&. Given the next data-type and the status of previously allocated slots, select the storage location for the parameter\&. The status array is indexed by \fIgroup:\fP a positive value indicates how many \fIslots\fP have been allocated from that group, and a -1 indicates the group/resource is fully consumed\&. 
.PP
\fBParameters:\fP
.RS 4
\fItp\fP is the data-type of the next parameter 
.br
\fIstatus\fP is an array marking how many \fIslots\fP have already been consumed in a group 
.RE
.PP
\fBReturns:\fP
.RS 4
the newly assigned address for the parameter 
.RE
.PP

.PP
Definition at line 437 of file fspec\&.cc\&.
.SS "void ParamListStandard::assignMap (const vector< \fBDatatype\fP * > & proto, bool isinput, \fBTypeFactory\fP & typefactory, vector< \fBParameterPieces\fP > & res) const\fC [virtual]\fP"

.PP
Given list of data-types, map the list positions to storage locations\&. If we know the function prototype, recover how parameters are actually stored using the model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIproto\fP is the ordered list of data-types 
.br
\fIisinput\fP is \fBtrue\fP for the input prototype, \fBfalse\fP for output prototype 
.br
\fItypefactory\fP is the \fBTypeFactory\fP (for constructing pointers) 
.br
\fIres\fP will contain the storage locations corresponding to the datatypes 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListMerged\fP, and \fBParamListStandardOut\fP\&.
.PP
Definition at line 459 of file fspec\&.cc\&.
.SS "\fBOpCode\fP ParamListStandard::assumedExtension (const \fBAddress\fP & addr, int4 size, \fBVarnodeData\fP & res) const\fC [virtual]\fP"

.PP
Get the type of extension and containing parameter for the given storage\&. If the given storage is properly contained within a normal parameter and the model typically extends a small value into the full container, pass back the full container and the type of extension\&. 
.PP
\fBParameters:\fP
.RS 4
\fIaddr\fP is the starting address of the given storage 
.br
\fIsize\fP is the number of bytes in the given storage 
.br
\fIres\fP is the parameter storage to pass back 
.RE
.PP
\fBReturns:\fP
.RS 4
the extension operator (INT_ZEXT INT_SEXT) or INT_COPY if there is no extension\&. INT_PIECE indicates the extension is determined by the specific prototype\&. 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 858 of file fspec\&.cc\&.
.SS "void ParamListStandard::buildTrialMap (\fBParamActive\fP * active) const\fC [protected]\fP"

.PP
Build map from parameter trials to model ParamEntrys\&. Given a set of \fBtrials\fP (putative \fBVarnode\fP parameters) as \fBParamTrial\fP objects, associate each trial with a model \fBParamEntry\fP within \fBthis\fP list\&. Trials for for which there are no matching entries are marked as unused\&. Any holes in the resource list are filled with \fIunreferenced\fP trials\&. The trial list is sorted\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the set of \fBtrials\fP to map and organize 
.RE
.PP

.PP
Definition at line 511 of file fspec\&.cc\&.
.SS "void ParamListStandard::calcDelay (void)\fC [protected]\fP"

.PP
Calculate the maximum heritage delay for any potential parameter in this list\&. 
.PP
Definition at line 748 of file fspec\&.cc\&.
.SS "bool ParamListStandard::checkJoin (const \fBAddress\fP & hiaddr, int4 hisize, const \fBAddress\fP & loaddr, int4 losize) const\fC [virtual]\fP"

.PP
Check if the given two storage locations can represent a single logical parameter\&. Within the conventions of this model, do the two (hi/lo) locations represent consecutive parameter locations that can be replaced by a single logical parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhiaddr\fP is the address of the most significant part of the value 
.br
\fIhisize\fP is the size of the most significant part in bytes 
.br
\fIloaddr\fP is the address of the least significant part of the value 
.br
\fIlosize\fP is the size of the least significant part in bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtrue\fP if the two pieces can be joined 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 782 of file fspec\&.cc\&.
.SS "bool ParamListStandard::checkSplit (const \fBAddress\fP & loc, int4 size, int4 splitpoint) const\fC [virtual]\fP"

.PP
Check if it makes sense to split a single storage location into two parameters\&. A storage location and split point is provided, implying two new storage locations\&. Does \fBthis\fP model allow these locations to be considered parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP is the starting address of provided storage location 
.br
\fIsize\fP is the size of the location in bytes 
.br
\fIsplitpoint\fP is the number of bytes to consider in the first (in address order) piece 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtrue\fP if the storage location can be split 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 810 of file fspec\&.cc\&.
.SS "\fBParamList\fP * ParamListStandard::clone (void) const\fC [virtual]\fP"

.PP
Clone this parameter list model\&. 
.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListMerged\fP, \fBParamListRegister\fP, and \fBParamListStandardOut\fP\&.
.PP
Definition at line 937 of file fspec\&.cc\&.
.SS "void ParamListStandard::fillinMap (\fBParamActive\fP * active) const\fC [virtual]\fP"

.PP
Given an unordered list of storage locations, calculate a function prototype\&. A list of input (or output) trials is given, which may have holes, invalid inputs etc\&. Decide on the formal ordered parameter list\&. Trials within the \fBParamActive\fP are added, removed, or reordered as needed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the given list of trials 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListMerged\fP, \fBParamListRegister\fP, and \fBParamListStandardOut\fP\&.
.PP
Definition at line 759 of file fspec\&.cc\&.
.SS "int4 ParamListStandard::findEntry (const \fBAddress\fP & loc, int4 size) const\fC [protected]\fP"

.PP
Given storage location find matching \fBParamEntry\fP\&. Find the (first) entry containing the given memory range 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP is the starting address of the range 
.br
\fIsize\fP is the number of bytes in the range 
.RE
.PP
\fBReturns:\fP
.RS 4
the index of the matching \fBParamEntry\fP or -1 if none exists 
.RE
.PP

.PP
Definition at line 419 of file fspec\&.cc\&.
.SS "void ParamListStandard::forceExclusionGroup (\fBParamActive\fP * active) const\fC [protected]\fP"

.PP
Enforce exclusion rules for the given set of parameter trials\&. If there are more than one active trials in a single group, and if that group is an exclusion group, mark all but the first trial to \fIinactive\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the set of trials 
.RE
.PP

.PP
Definition at line 636 of file fspec\&.cc\&.
.SS "void ParamListStandard::forceInactiveChain (\fBParamActive\fP * active, int4 maxchain, int4 start, int4 stop) const\fC [protected]\fP"

.PP
Enforce rules about chains of inactive slots\&. If there is a chain of slots whose length is greater than \fBmaxchain\fP, where all trials are \fIinactive\fP, mark trials in any later slot as \fIinactive\fP\&. Mark any \fIinactive\fP trials before this (that aren't in a maximal chain) as active\&. Inspection and marking is restricted to a given range of trials to facilitate separate analysis of floating-point and general-purpose resources\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the set of trials, which must be sorted 
.br
\fImaxchain\fP is the maximum number of \fIinactive\fP trials to allow in a chain 
.br
\fIstart\fP is the first index in the range of trials to consider 
.br
\fIstop\fP is the last index (+1) in the range of trials to consider 
.RE
.PP

.PP
Definition at line 703 of file fspec\&.cc\&.
.SS "void ParamListStandard::forceNoUse (\fBParamActive\fP * active, int4 start, int4 stop) const\fC [protected]\fP"

.PP
Mark every trial above the first 'definitely not used' as \fIinactive\fP\&. Inspection and marking only occurs within an indicated range of trials, allowing floating-point and general purpose resources to be treated separately\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the set of trials, which must already be ordered 
.br
\fIstart\fP is the index of the first trial in the range to consider 
.br
\fIstop\fP is the index (+1) of the last trial in the range to consider 
.RE
.PP

.PP
Definition at line 664 of file fspec\&.cc\&.
.SS "const vector<\fBParamEntry\fP>& ParamListStandard::getEntry (void) const\fC [inline]\fP"

.PP
Get the list of parameter entries\&. 
.PP
Definition at line 449 of file fspec\&.hh\&.
.SS "virtual int4 ParamListStandard::getMaxDelay (void) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Return the maximum heritage delay across all possible parameters\&. Depending on the address space, data-flow for a parameter may not be available until extra transform passes have completed\&. This method returns the number of passes that must occur before we can guarantee that all parameters have data-flow info\&. 
.PP
\fBReturns:\fP
.RS 4
the maximum number of passes across all parameters in \fBthis\fP model 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 462 of file fspec\&.hh\&.
.SS "void ParamListStandard::getRangeList (\fBAddrSpace\fP * spc, \fBRangeList\fP & res) const\fC [virtual]\fP"

.PP
For a given address space, collect all the parameter locations within that space\&. Pass back the memory ranges for any parameter that is stored in the given address space\&. 
.PP
\fBParameters:\fP
.RS 4
\fIspc\fP is the given address space 
.br
\fIres\fP will hold the set of matching memory ranges 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 870 of file fspec\&.cc\&.
.SS "virtual \fBAddrSpace\fP* ParamListStandard::getSpacebase (void) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Get the address space associated with any stack based parameters in \fBthis\fP list\&. 
.PP
\fBReturns:\fP
.RS 4
the stack address space, if \fBthis\fP models parameters passed on the stack, NULL otherwise 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 460 of file fspec\&.hh\&.
.SS "virtual uint4 ParamListStandard::getType (void) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Get the type of parameter list\&. 
.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListMerged\fP, \fBParamListRegister\fP, and \fBParamListStandardOut\fP\&.
.PP
Definition at line 450 of file fspec\&.hh\&.
.SS "bool ParamListStandard::possibleParam (const \fBAddress\fP & loc, int4 size) const\fC [virtual]\fP"

.PP
Does the given storage location make sense as a parameter\&. Within \fBthis\fP model, decide if the storage location can be considered a parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP is the starting address of the storage location 
.br
\fIsize\fP is the number of bytes in the storage location 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtrue\fP if the location can be a parameter 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListStandardOut\fP\&.
.PP
Definition at line 822 of file fspec\&.cc\&.
.SS "bool ParamListStandard::possibleParamWithSlot (const \fBAddress\fP & loc, int4 size, int4 & slot, int4 & slotsize) const\fC [virtual]\fP"

.PP
Pass-back the slot and slot size for the given storage location as a parameter\&. This checks if the given storage location acts as a parameter in \fBthis\fP model and passes back the number of slots that it occupies\&. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP is the starting address of the storage location 
.br
\fIsize\fP is the number of bytes in the storage location 
.br
\fIslot\fP if the \fIslot\fP number to pass back 
.br
\fIslotsize\fP is the number of consumed slots to pass back 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtrue\fP if the location can be a parameter 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 828 of file fspec\&.cc\&.
.SS "void ParamListStandard::restoreXml (const \fBElement\fP * el, const \fBAddrSpaceManager\fP * manage, vector< \fBEffectRecord\fP > & effectlist, bool normalstack)\fC [virtual]\fP"

.PP
Restore the model from an XML stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIel\fP is the root <input> or <output> element 
.br
\fImanage\fP is used to resolve references to address spaces 
.br
\fIeffectlist\fP is a container collecting EffectRecords across all parameters 
.br
\fInormalstack\fP is \fBtrue\fP if parameters are pushed on the stack in the normal order 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Reimplemented in \fBParamListStandardOut\fP\&.
.PP
Definition at line 882 of file fspec\&.cc\&.
.SS "void ParamListStandard::separateFloat (\fBParamActive\fP * active, int4 & floatstart, int4 & floatstop, int4 & start, int4 & stop) const\fC [protected]\fP"

.PP
Calculate the range of floating-point entries within a given set of parameter \fItrials\fP\&. The trials must already be mapped, which should put floating-point entries first\&. This method calculates the range of floating-point entries and the range of general purpose entries and passes them back\&. 
.PP
\fBParameters:\fP
.RS 4
\fIactive\fP is the given set of parameter trials 
.br
\fIfloatstart\fP will pass back the index of the first floating-point trial 
.br
\fIfloatstop\fP will pass back the index (+1) of the last floating-point trial 
.br
\fIstart\fP will pass back the index of the first general purpose trial 
.br
\fIstop\fP will pass back the index (+1) of the last general purpose trial 
.RE
.PP

.PP
Definition at line 615 of file fspec\&.cc\&.
.SS "bool ParamListStandard::unjustifiedContainer (const \fBAddress\fP & loc, int4 size, \fBVarnodeData\fP & res) const\fC [virtual]\fP"

.PP
Check if the given storage location looks like an \fIunjustified\fP parameter\&. The storage for a value may be contained in a normal parameter location but be unjustified within that container, i\&.e\&. the least significant bytes are not being used\&. If this is the case, pass back the full parameter location and return \fBtrue\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP is the starting address of the given storage 
.br
\fIsize\fP is the number of bytes in the given storage 
.br
\fIres\fP is the full parameter storage to pass back 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtrue\fP if the given storage is unjustified within its parameter container 
.RE
.PP

.PP
Implements \fBParamList\fP\&.
.PP
Definition at line 844 of file fspec\&.cc\&.
.SH "Member Data Documentation"
.PP 
.SS "vector<\fBParamEntry\fP> ParamListStandard::entry\fC [protected]\fP"

.PP
The ordered list of parameter entries\&. 
.PP
Definition at line 436 of file fspec\&.hh\&.
.SS "int4 ParamListStandard::maxdelay\fC [protected]\fP"

.PP
Maximum heritage delay across all parameters\&. 
.PP
Definition at line 432 of file fspec\&.hh\&.
.SS "int4 ParamListStandard::nonfloatgroup\fC [protected]\fP"

.PP
Group of first entry which is not marked float\&. 
.PP
Definition at line 435 of file fspec\&.hh\&.
.SS "int4 ParamListStandard::numgroup\fC [protected]\fP"

.PP
Number of \fIgroups\fP in this parameter convention\&. 
.PP
Definition at line 431 of file fspec\&.hh\&.
.SS "int4 ParamListStandard::pointermax\fC [protected]\fP"

.PP
If non-zero, maximum size of a data-type before converting to a pointer\&. 
.PP
Definition at line 433 of file fspec\&.hh\&.
.SS "\fBAddrSpace\fP* ParamListStandard::spacebase\fC [protected]\fP"

.PP
\fBAddress\fP space containing relative offset parameters\&. 
.PP
Definition at line 437 of file fspec\&.hh\&.
.SS "bool ParamListStandard::thisbeforeret\fC [protected]\fP"

.PP
Does a \fBthis\fP parameter come before a hidden return parameter\&. 
.PP
Definition at line 434 of file fspec\&.hh\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for decompile from the source code\&.
