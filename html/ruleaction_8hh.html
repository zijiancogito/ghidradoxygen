<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompile: F:/re/ghidra_sourcecode/ghidra/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.hh File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompile
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_4d2dc98e227541a044ee6b67b5d94912.html">decompile</a></li><li class="navelem"><a class="el" href="dir_55276c5a5d4e3061aa19bfeed56bd607.html">cpp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">ruleaction.hh File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the basic set of transformation <a class="el" href="class_rule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> objects.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="action_8hh_source.html">action.hh</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ruleaction.hh:</div>
<div class="dyncontent">
<div class="center"><img src="ruleaction_8hh__incl.png" border="0" usemap="#_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hh" alt=""/></div>
<map name="_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hh" id="_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hh">
<area shape="rect"  title="This is the basic set of transformation Rule objects." alt="" coords="335,5,511,76"/>
<area shape="rect"  href="action_8hh.html" title="Action, Rule, and other associates classes supporting transformations on function data&#45;flow." alt="" coords="385,124,460,151"/>
<area shape="rect"  href="block_8hh.html" title="Classes related to basic blocks and control&#45;flow structuring." alt="" coords="387,199,458,225"/>
<area shape="rect"  href="jumptable_8hh.html" title=" " alt="" coords="375,273,471,300"/>
<area shape="rect"  href="emulateutil_8hh.html" title="(Lightweight) emulation interface for executing PcodeOp objects within a syntax tree or for executing..." alt="" coords="431,348,534,375"/>
<area shape="rect"  href="rangeutil_8hh.html" title="Documentation for the CircleRange class." alt="" coords="318,348,407,375"/>
<area shape="rect"  href="emulate_8hh.html" title="Classes for emulating p&#45;code." alt="" coords="439,647,526,673"/>
<area shape="rect"  href="op_8hh.html" title="The PcodeOp and PcodeOpBank classes." alt="" coords="338,423,393,449"/>
<area shape="rect"  href="memstate_8hh.html" title="Classes for keeping track of memory state during emulation." alt="" coords="517,721,616,748"/>
<area shape="rect"  href="translate_8hh.html" title="Classes for disassembly and pcode generation." alt="" coords="403,721,493,748"/>
<area shape="rect"  href="pcoderaw_8hh.html" title="Raw descriptions of varnodes and p&#45;code ops." alt="" coords="545,796,639,823"/>
<area shape="rect"  href="loadimage_8hh.html" title="Classes and API for accessing a binary load image." alt="" coords="421,796,520,823"/>
<area shape="rect"  href="address_8hh.html" title="Classes for specifying addresses and other low&#45;level constants." alt="" coords="429,871,515,897"/>
<area shape="rect"  href="opbehavior_8hh.html" title="Classes for describing the behavior of individual p&#45;code operations." alt="" coords="541,871,643,897"/>
<area shape="rect"  href="space_8hh.html" title="Classes for describing address spaces." alt="" coords="480,945,555,972"/>
<area shape="rect"  href="error_8hh.html" title="Base class for error handling facilities." alt="" coords="559,1020,625,1047"/>
<area shape="rect"  href="xml_8hh.html" title=" " alt="" coords="299,1020,360,1047"/>
<area shape="rect"  href="types_8h.html" title=" " alt="" coords="217,1095,282,1121"/>
<area shape="rect"  title=" " alt="" coords="557,1095,627,1121"/>
<area shape="rect"  title=" " alt="" coords="377,1095,442,1121"/>
<area shape="rect"  title=" " alt="" coords="467,1095,533,1121"/>
<area shape="rect"  title=" " alt="" coords="306,1095,353,1121"/>
<area shape="rect"  title=" " alt="" coords="651,1095,691,1121"/>
<area shape="rect"  title=" " alt="" coords="715,1095,754,1121"/>
<area shape="rect"  title=" " alt="" coords="136,1095,192,1121"/>
<area shape="rect"  title=" " alt="" coords="779,1095,853,1121"/>
<area shape="rect"  title=" " alt="" coords="877,1095,939,1121"/>
<area shape="rect"  title=" " alt="" coords="963,1095,1024,1121"/>
<area shape="rect"  title=" " alt="" coords="57,1095,111,1121"/>
<area shape="rect"  href="opcodes_8hh.html" title="All the individual p&#45;code operations." alt="" coords="366,945,455,972"/>
<area shape="rect"  href="float_8hh.html" title="Support for decoding different floating&#45;point formats." alt="" coords="317,871,381,897"/>
<area shape="rect"  href="typeop_8hh.html" title="Data&#45;type and behavior information associated with specific p&#45;code op&#45;codes." alt="" coords="326,497,405,524"/>
<area shape="rect"  href="cpool_8hh.html" title="Definitions to support a constant pool for deferred compilation languages (i.e. java byte&#45;code)" alt="" coords="234,572,305,599"/>
<area shape="rect"  href="variable_8hh.html" title="Definitions for high&#45;level variables." alt="" coords="329,572,412,599"/>
<area shape="rect"  href="printlanguage_8hh.html" title="Classes for printing tokens in a high&#45;level language." alt="" coords="67,647,184,673"/>
<area shape="rect"  href="type_8hh.html" title="Classes for describing and printing data&#45;types." alt="" coords="237,796,302,823"/>
<area shape="rect"  href="varnode_8hh.html" title="The Varnode and VarnodeBank classes." alt="" coords="329,647,413,673"/>
<area shape="rect"  href="cover_8hh.html" title="Classes describing the topological scope of variables within a function." alt="" coords="307,721,378,748"/>
<area shape="rect"  href="capability_8hh.html" title="Infrastructure for discovering code extensions to the decompiler." alt="" coords="119,1020,214,1047"/>
<area shape="rect"  href="cast_8hh.html" title="API and specific strategies for applying type casts." alt="" coords="43,721,109,748"/>
<area shape="rect"  href="prettyprint_8hh.html" title="Routines for emitting high&#45;level (C) language syntax in a well formatted way." alt="" coords="133,721,232,748"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ruleaction_8hh__dep__incl.png" border="0" usemap="#_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hhdep" alt=""/></div>
<map name="_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hhdep" id="_f_1_2re_2ghidra__sourcecode_2ghidra_2_ghidra_2_features_2_decompiler_2src_2decompile_2cpp_2ruleaction_8hhdep">
<area shape="rect"  title="This is the basic set of transformation Rule objects." alt="" coords="443,5,619,76"/>
<area shape="rect"  href="coreaction_8hh.html" title="Core decompilation actions which are indepedent of any particular architecture." alt="" coords="317,124,493,195"/>
<area shape="rect"  href="ruleaction_8cc.html" title=" " alt="" coords="405,243,581,313"/>
<area shape="rect"  href="double_8hh.html" title=" " alt="" coords="605,124,781,195"/>
<area shape="rect"  href="action_8cc.html" title=" " alt="" coords="205,243,381,313"/>
<area shape="rect"  href="architecture_8cc.html" title=" " alt="" coords="5,243,181,313"/>
<area shape="rect"  href="coreaction_8cc.html" title=" " alt="" coords="605,243,781,313"/>
<area shape="rect"  href="double_8cc.html" title=" " alt="" coords="805,243,981,313"/>
</map>
</div>
</div>
<p><a href="ruleaction_8hh_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_add_tree_state.html">AddTreeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for sorting out pointer expression trees.  <a href="class_add_tree_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_early_removal.html">RuleEarlyRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rid of unused <a class="el" href="class_pcode_op.html" title="Lowest level operation of the p-code language.">PcodeOp</a> objects where we can guarantee the output is unused.  <a href="class_rule_early_removal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_collect_terms.html">RuleCollectTerms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect terms in a sum: <code>V * c + V * d =&gt; V * (c + d)</code>  <a href="class_rule_collect_terms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_select_cse.html">RuleSelectCse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for common sub-expressions (built out of a restricted set of ops)  <a href="class_rule_select_cse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_piece2_zext.html">RulePiece2Zext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with 0 becomes an extension: <code>V = concat(#0,W) =&gt; V = zext(W)</code>  <a href="class_rule_piece2_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_piece2_sext.html">RulePiece2Sext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with sign bits becomes an extension: <code>concat( V s&gt;&gt; #0x1f , V) =&gt; sext(V)</code>  <a href="class_rule_piece2_sext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_bxor2_not_equal.html">RuleBxor2NotEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate BOOL_XOR: <code>V ^^ W =&gt; V != W</code>  <a href="class_rule_bxor2_not_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_or_mask.html">RuleOrMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_OR with full mask: <code>V = W | 0xffff =&gt; V = W</code>  <a href="class_rule_or_mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_mask.html">RuleAndMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse unnecessary INT_AND.  <a href="class_rule_and_mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_or_collapse.html">RuleOrCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse unnecessary INT_OR.  <a href="class_rule_or_collapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_or_lump.html">RuleAndOrLump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constants in logical expressions: <code>(V &amp; c) &amp; d =&gt; V &amp; (c &amp; d)</code>  <a href="class_rule_and_or_lump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_negate_identity.html">RuleNegateIdentity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply INT_NEGATE identities: <code>V &amp; ~V =&gt; #0, V | ~V -&gt; #-1</code>  <a href="class_rule_negate_identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift_bitops.html">RuleShiftBitops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifting away all non-zero bits of one-side of a logical/arithmetic op.  <a href="class_rule_shift_bitops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_int_less_equal.html">RuleIntLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert LESSEQUAL to LESS: <code>V &lt;= c =&gt; V &lt; (c+1)</code>  <a href="class_rule_int_less_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_equality.html">RuleEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse INT_EQUAL and INT_NOTEQUAL: <code>f(V,W) == f(V,W) =&gt; true</code>  <a href="class_rule_equality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_term_order.html">RuleTermOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order the inputs to commutative operations.  <a href="class_rule_term_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_pullsub_multi.html">RulePullsubMulti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull SUBPIECE back through MULTIEQUAL.  <a href="class_rule_pullsub_multi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_pullsub_indirect.html">RulePullsubIndirect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull-back SUBPIECE through INDIRECT.  <a href="class_rule_pullsub_indirect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_push_multi.html">RulePushMulti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify MULTIEQUAL operations where the branches hold the same value.  <a href="class_rule_push_multi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_not_distribute.html">RuleNotDistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute BOOL_NEGATE: <code>!(V &amp;&amp; W) =&gt; !V || !W</code>  <a href="class_rule_not_distribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_high_order_and.html">RuleHighOrderAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_AND when applied to aligned INT_ADD: <code>(V + c) &amp; 0xfff0 =&gt; V + (c &amp; 0xfff0)</code>  <a href="class_rule_high_order_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_distribute.html">RuleAndDistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute INT_AND through INT_OR if result is simpler.  <a href="class_rule_and_distribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_less_one.html">RuleLessOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_LESS of 0 or 1: <code>V &lt; 1 =&gt; V == 0, V &lt;= 0 =&gt; V == 0</code>  <a href="class_rule_less_one.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_range_meld.html">RuleRangeMeld</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_merge.html" title="Class for merging low-level Varnodes into high-level HighVariables.">Merge</a> range conditions of the form: <code>V s&lt; c, c s&lt; V, V == c, V != c</code>  <a href="class_rule_range_meld.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_float_range.html">RuleFloatRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_merge.html" title="Class for merging low-level Varnodes into high-level HighVariables.">Merge</a> range conditions of the form: <code>V f&lt; c, c f&lt; V, V f== c</code> etc.  <a href="class_rule_float_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_commute.html">RuleAndCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute INT_AND with INT_LEFT and INT_RIGHT: <code>(V &lt;&lt; W) &amp; d =&gt; (V &amp; (W &gt;&gt; c)) &lt;&lt; c</code>  <a href="class_rule_and_commute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_piece.html">RuleAndPiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert PIECE to INT_ZEXT where appropriate: <code>V &amp; concat(W,X) =&gt; zext(X)</code>  <a href="class_rule_and_piece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_and_compare.html">RuleAndCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_ZEXT and SUBPIECE in masked comparison: <code>zext(V) &amp; c == 0 =&gt; V &amp; (c &amp; mask) == 0</code>  <a href="class_rule_and_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_double_sub.html">RuleDoubleSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify chained SUBPIECE: <code>sub( sub(V,c), d) =&gt; sub(V, c+d)</code>  <a href="class_rule_double_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_double_shift.html">RuleDoubleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify chained shifts INT_LEFT and INT_RIGHT.  <a href="class_rule_double_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_concat_shift.html">RuleConcatShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_RIGHT canceling PIECE: <code>concat(V,W) &gt;&gt; c =&gt; zext(V)</code>  <a href="class_rule_concat_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_left_right.html">RuleLeftRight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform canceling INT_RIGHT or INT_SRIGHT of INT_LEFT.  <a href="class_rule_left_right.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift_compare.html">RuleShiftCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform shifts in comparisons: <code>V &gt;&gt; c == d =&gt; V == (d &lt;&lt; c)</code>  <a href="class_rule_shift_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_less_equal.html">RuleLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify 'less than or equal': <code>V &lt; W || V == W =&gt; V &lt;= W</code>  <a href="class_rule_less_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_less_not_equal.html">RuleLessNotEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESSEQUAL &amp;&amp; INT_NOTEQUAL: <code>V &lt;= W &amp;&amp; V != W =&gt; V &lt; W</code>  <a href="class_rule_less_not_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_trivial_arith.html">RuleTrivialArith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify trivial arithmetic expressions.  <a href="class_rule_trivial_arith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_trivial_bool.html">RuleTrivialBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify boolean expressions when one side is constant.  <a href="class_rule_trivial_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_zext_eliminate.html">RuleZextEliminate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_ZEXT in comparisons: <code>zext(V) == c =&gt; V == c</code>  <a href="class_rule_zext_eliminate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sless_to_less.html">RuleSlessToLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_SLESS to INT_LESS when comparing positive values.  <a href="class_rule_sless_to_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_zext_sless.html">RuleZextSless</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_ZEXT and INT_SLESS: <code>zext(V) s&lt; c =&gt; V &lt; c</code>  <a href="class_rule_zext_sless.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_bit_undistribute.html">RuleBitUndistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo distributed operations through INT_AND, INT_OR, and INT_XOR.  <a href="class_rule_bit_undistribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_boolean_negate.html">RuleBooleanNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify comparisons with boolean values: <code>V == false =&gt; !V, V == true =&gt; V</code>  <a href="class_rule_boolean_negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_bool_zext.html">RuleBoolZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify boolean expressions of the form zext(V) * -1.  <a href="class_rule_bool_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_logic2_bool.html">RuleLogic2Bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert logical to boolean operations: <code>V &amp; W =&gt; V &amp;&amp; W, V | W =&gt; V || W</code>  <a href="class_rule_logic2_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_indirect_collapse.html">RuleIndirectCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a CPUI_INDIRECT if its blocking <a class="el" href="class_pcode_op.html" title="Lowest level operation of the p-code language.">PcodeOp</a> is dead.  <a href="class_rule_indirect_collapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_multi_collapse.html">RuleMultiCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse MULTIEQUAL whose inputs all trace to the same value.  <a href="class_rule_multi_collapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sborrow.html">RuleSborrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify signed comparisons using INT_SBORROW.  <a href="class_rule_sborrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_trivial_shift.html">RuleTrivialShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify trivial shifts: <code>V &lt;&lt; 0 =&gt; V, V &lt;&lt; #64 =&gt; 0</code>  <a href="class_rule_trivial_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_identity_el.html">RuleIdentityEl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse operations using identity element: <code>V + 0 =&gt; V</code>  <a href="class_rule_identity_el.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift2_mult.html">RuleShift2Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_LEFT to INT_MULT: <code>V &lt;&lt; 2 =&gt; V * 4</code>  <a href="class_rule_shift2_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift_piece.html">RuleShiftPiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "shift and add" to PIECE: (zext(V) &lt;&lt; 16) + zext(W) =&gt; concat(V,W)  <a href="class_rule_shift_piece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_collapse_constants.html">RuleCollapseConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constant expressions.  <a href="class_rule_collapse_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_transform_cpool.html">RuleTransformCpool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform CPOOLREF operations by looking up the value in the constant pool.  <a href="class_rule_transform_cpool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_propagate_copy.html">RulePropagateCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate the input of a COPY to all the places that read the output.  <a href="class_rule_propagate_copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule2_comp2_mult.html">Rule2Comp2Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_2COMP: <code>-V =&gt; V * -1</code>  <a href="class_rule2_comp2_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_carry_elim.html">RuleCarryElim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_CARRY using a constant: <code>carry(V,c) =&gt; -c &lt;= V</code>  <a href="class_rule_carry_elim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub2_add.html">RuleSub2Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_SUB: <code>V - W =&gt; V + W * -1</code>  <a href="class_rule_sub2_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_xor_collapse.html">RuleXorCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_XOR in comparisons: <code>(V ^ W) == 0 =&gt; V == W</code>  <a href="class_rule_xor_collapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_add_mult_collapse.html">RuleAddMultCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constants in an additive or multiplicative expression.  <a href="class_rule_add_mult_collapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_load_varnode.html">RuleLoadVarnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert LOAD operations using a constant offset to COPY.  <a href="class_rule_load_varnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_store_varnode.html">RuleStoreVarnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert STORE operations using a constant offset to COPY.  <a href="class_rule_store_varnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_ext_comm.html">RuleSubExtComm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute SUBPIECE and INT_ZEXT: <code>sub(zext(V),c) =&gt; zext(sub(V,c))</code>  <a href="class_rule_sub_ext_comm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_commute.html">RuleSubCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute SUBPIECE operations with earlier operations where possible.  <a href="class_rule_sub_commute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_concat_commute.html">RuleConcatCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute PIECE with INT_AND, INT_OR, and INT_XOR.  <a href="class_rule_concat_commute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_concat_zext.html">RuleConcatZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute PIECE with INT_ZEXT: <code>concat(zext(V),W) =&gt; zext(concat(V,W))</code>  <a href="class_rule_concat_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_zext_commute.html">RuleZextCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute INT_ZEXT with INT_RIGHT: <code>zext(V) &gt;&gt; W =&gt; zext(V &gt;&gt; W)</code>  <a href="class_rule_zext_commute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_zext_shift_zext.html">RuleZextShiftZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify multiple INT_ZEXT operations: <code>zext( zext(V) &lt;&lt; c ) =&gt; zext(V) &lt;&lt; c</code>  <a href="class_rule_zext_shift_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift_and.html">RuleShiftAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate any INT_AND when the bits it zeroes out are discarded by a shift.  <a href="class_rule_shift_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_concat_zero.html">RuleConcatZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify concatenation with zero: <code>concat(V,0) =&gt; zext(V) &lt;&lt; c</code>  <a href="class_rule_concat_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_concat_left_shift.html">RuleConcatLeftShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify concatenation of extended value: <code>concat(V, zext(W) &lt;&lt; c) =&gt; concat( concat(V,W), 0)</code>  <a href="class_rule_concat_left_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_zext.html">RuleSubZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_ZEXT applied to SUBPIECE expressions.  <a href="class_rule_sub_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_cancel.html">RuleSubCancel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify composition of SUBPIECE with INT_ZEXT or INT_SEXT.  <a href="class_rule_sub_cancel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_shift_sub.html">RuleShiftSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify SUBPIECE applied to INT_LEFT: <code>sub( V &lt;&lt; 8*c, c) =&gt; sub(V,0)</code>  <a href="class_rule_shift_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_humpty_dumpty.html">RuleHumptyDumpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify break and rejoin: <code>concat( sub(V,c), sub(V,0) ) =&gt; V</code>  <a href="class_rule_humpty_dumpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_dumpty_hump.html">RuleDumptyHump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify join and break apart: <code>sub( concat(V,W), c) =&gt; sub(W,c)</code>  <a href="class_rule_dumpty_hump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_humpty_or.html">RuleHumptyOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify masked pieces INT_ORed together: <code>(V &amp; ff00) | (V &amp; 00ff) =&gt; V</code>  <a href="class_rule_humpty_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_embed.html">RuleEmbed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify PIECE intended as embedding: <code>concat(V, sub(W,0)) =&gt; W &amp; 0xff | (zext(W) &lt;&lt; 8)</code>  <a href="class_rule_embed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_switch_single.html">RuleSwitchSingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert BRANCHIND with only one computed destination to a BRANCH.  <a href="class_rule_switch_single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_cond_negate.html">RuleCondNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip conditions to match structuring cues.  <a href="class_rule_cond_negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_bool_negate.html">RuleBoolNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a set of identities involving BOOL_NEGATE.  <a href="class_rule_bool_negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_less2_zero.html">RuleLess2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESS applied to extremal constants.  <a href="class_rule_less2_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_less_equal2_zero.html">RuleLessEqual2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESSEQUAL applied to extremal constants.  <a href="class_rule_less_equal2_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_s_less2_zero.html">RuleSLess2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_SLESS and INT_SLESSEQUAL applied to 0 or -1.  <a href="class_rule_s_less2_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_equal2_zero.html">RuleEqual2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_EQUAL applied to 0: <code>0 == V + W * -1 =&gt; V == W or 0 == V + c =&gt; V == -c</code>  <a href="class_rule_equal2_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_equal2_constant.html">RuleEqual2Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_EQUAL applied to arithmetic expressions.  <a href="class_rule_equal2_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ptr_arith.html">RulePtrArith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pointer arithmetic.  <a href="class_rule_ptr_arith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_struct_offset0.html">RuleStructOffset0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a LOAD or STORE to the first element of a structure to a PTRSUB.  <a href="class_rule_struct_offset0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_push_ptr.html">RulePushPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a <a class="el" href="class_varnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> with known pointer data-type to the bottom of its additive expression.  <a href="class_rule_push_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ptradd_undo.html">RulePtraddUndo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove PTRADD operations with mismatched data-type information.  <a href="class_rule_ptradd_undo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ptrsub_undo.html">RulePtrsubUndo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove PTRSUB operations with mismatched data-type information.  <a href="class_rule_ptrsub_undo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_mult_neg_one.html">RuleMultNegOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_2COMP from INT_MULT: <code>V * -1 =&gt; -V</code>  <a href="class_rule_mult_neg_one.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_add_unsigned.html">RuleAddUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_ADD of constants to INT_SUB: <code>V + 0xff... =&gt; V - 0x00...</code>  <a href="class_rule_add_unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule2_comp2_sub.html">Rule2Comp2Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_ADD back to INT_SUB: <code>V + -W ==&gt; V - W</code>  <a href="class_rule2_comp2_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_right.html">RuleSubRight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert truncation to cast: <code>sub(V,c) =&gt; sub(V&gt;&gt;c*8,0)</code>  <a href="class_rule_sub_right.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ptrsub_char_constant.html">RulePtrsubCharConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Set-up to print string constants.  <a href="class_rule_ptrsub_char_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sub_normal.html">RuleSubNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull-back SUBPIECE through INT_RIGHT and INT_SRIGHT.  <a href="class_rule_sub_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_div_term_add.html">RuleDivTermAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions associated with optimized division expressions.  <a href="class_rule_div_term_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_div_term_add2.html">RuleDivTermAdd2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify another expression associated with optimized division.  <a href="class_rule_div_term_add2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_div_opt.html">RuleDivOpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_MULT and shift forms into INT_DIV or INT_SDIV.  <a href="class_rule_div_opt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sign_div2.html">RuleSignDiv2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_SRIGHT form into INT_SDIV: <code>(V + -1*(V s&gt;&gt; 31)) s&gt;&gt; 1 =&gt; V s/ 2</code>  <a href="class_rule_sign_div2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sign_form.html">RuleSignForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize sign extraction: <code>sub(sext(V),c) =&gt; V s&gt;&gt; 31</code>  <a href="class_rule_sign_form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_sign_near_mult.html">RuleSignNearMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify division form: <code>(V + (V s&gt;&gt; 0x1f)&gt;&gt;(32-n)) &amp; (-1&lt;&lt;n) =&gt; (V s/ 2^n) * 2^n</code>  <a href="class_rule_sign_near_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_mod_opt.html">RuleModOpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions that optimize INT_REM and INT_SREM.  <a href="class_rule_mod_opt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_segment.html">RuleSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate constants through a SEGMENTOP.  <a href="class_rule_segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_and.html">RuleSubvarAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SubVariableFlow analysis triggered by INT_AND.  <a href="class_rule_subvar_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_subpiece.html">RuleSubvarSubpiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SubVariableFlow analysis triggered by SUBPIECE.  <a href="class_rule_subvar_subpiece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_split_flow.html">RuleSplitFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to detect and split artificially joined Varnodes.  <a href="class_rule_split_flow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ptr_flow.html">RulePtrFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="class_varnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> and <a class="el" href="class_pcode_op.html" title="Lowest level operation of the p-code language.">PcodeOp</a> objects that are carrying or operating on pointers.  <a href="class_rule_ptr_flow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_comp_zero.html">RuleSubvarCompZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="class_subvariable_flow.html">SubvariableFlow</a> analysis triggered by testing of a single bit.  <a href="class_rule_subvar_comp_zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_shift.html">RuleSubvarShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="class_subvariable_flow.html">SubvariableFlow</a> analysis triggered by INT_RIGHT.  <a href="class_rule_subvar_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_zext.html">RuleSubvarZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="class_subvariable_flow.html">SubvariableFlow</a> analysis triggered by INT_ZEXT.  <a href="class_rule_subvar_zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subvar_sext.html">RuleSubvarSext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="class_subvariable_flow.html">SubvariableFlow</a> analysis triggered by INT_SEXT.  <a href="class_rule_subvar_sext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_subfloat_convert.html">RuleSubfloatConvert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="class_subfloat_flow.html">SubfloatFlow</a> analysis triggered by FLOAT_FLOAT2FLOAT.  <a href="class_rule_subfloat_convert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_negate_negate.html">RuleNegateNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_NEGATE chains: <code>~~V =&gt; V</code>  <a href="class_rule_negate_negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_conditional_move.html">RuleConditionalMove</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify various conditional move situations.  <a href="class_rule_conditional_move.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_float_cast.html">RuleFloatCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace (casttosmall)(casttobig)V with identity or with single cast.  <a href="class_rule_float_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_ignore_nan.html">RuleIgnoreNan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat FLOAT_NAN as always evaluating to false.  <a href="class_rule_ignore_nan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_func_ptr_encoding.html">RuleFuncPtrEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate ARM/THUMB style masking of the low order bits on function pointers.  <a href="class_rule_func_ptr_encoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule_three_way_compare.html">RuleThreeWayCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions involving <em>three-way</em> comparisons.  <a href="class_rule_three_way_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the basic set of transformation <a class="el" href="class_rule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> objects. </p>
<p>Each <a class="el" href="class_rule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> triggers on a specific localized data-flow configuration. They are generally applied simultaneously from a pool (see <a class="el" href="class_action_pool.html" title="A pool of Rules that apply simultaneously.">ActionPool</a>) and can interact with each other to produce an emergent transformation. The Rules are applied repeatedly until no <a class="el" href="class_rule.html" title="Class for performing a single transformation on a PcodeOp or Varnode.">Rule</a> can make any additional transformations. </p>

<p class="definition">Definition in file <a class="el" href="ruleaction_8hh_source.html">ruleaction.hh</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
